<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Marine Library: COutByteStreamBasic&lt; Data &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marine Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for Linux Networking Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCOutByteStreamBasic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">COutByteStreamBasic&lt; Data &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data packing interfaces.  
 <a href="classCOutByteStreamBasic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="data__stream_8hh_source.html">data_stream.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for COutByteStreamBasic&lt; Data &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCOutByteStreamBasic__inherit__graph.png" border="0" usemap="#COutByteStreamBasic_3_01Data_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for COutByteStreamBasic&lt; Data &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classCOutByteStreamBasic__coll__graph.png" border="0" usemap="#COutByteStreamBasic_3_01Data_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acda3b2ccf4c56b1f063b4bea42ac9000"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acda3b2ccf4c56b1f063b4bea42ac9000"></a>
typedef Data::__Buf&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_type</b></td></tr>
<tr class="separator:acda3b2ccf4c56b1f063b4bea42ac9000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2dd5a6f7242dad1ce1badd814e368f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a2dd5a6f7242dad1ce1badd814e368f"></a>
typedef Data::__Char&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="separator:a3a2dd5a6f7242dad1ce1badd814e368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aecf5d35bab5a6cb4d021d98f537f3cff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#aecf5d35bab5a6cb4d021d98f537f3cff">COutByteStreamBasic</a> (size_t reserve=1024, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:aecf5d35bab5a6cb4d021d98f537f3cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for COutByteStream/COutByteStreamStr, COutByteStreamVec.  <a href="#aecf5d35bab5a6cb4d021d98f537f3cff">More...</a><br /></td></tr>
<tr class="separator:aecf5d35bab5a6cb4d021d98f537f3cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bce67b3566da7af882d7e1fe062e79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#ae2bce67b3566da7af882d7e1fe062e79">COutByteStreamBasic</a> (buffer_type &amp;buf, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:ae2bce67b3566da7af882d7e1fe062e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for COutByteStreamStrRef, COutByteStreamVecRef.  <a href="#ae2bce67b3566da7af882d7e1fe062e79">More...</a><br /></td></tr>
<tr class="separator:ae2bce67b3566da7af882d7e1fe062e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4769c890371073dcd563698311de1f8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a4769c890371073dcd563698311de1f8f">COutByteStreamBasic</a> (char_type *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:a4769c890371073dcd563698311de1f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for COutByteStreamBuf.  <a href="#a4769c890371073dcd563698311de1f8f">More...</a><br /></td></tr>
<tr class="separator:a4769c890371073dcd563698311de1f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d94dce28c70e9b6510ba68eb3c9b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a06d94dce28c70e9b6510ba68eb3c9b04">bad</a> (int code)</td></tr>
<tr class="memdesc:a06d94dce28c70e9b6510ba68eb3c9b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>status</em>.  <a href="#a06d94dce28c70e9b6510ba68eb3c9b04">More...</a><br /></td></tr>
<tr class="separator:a06d94dce28c70e9b6510ba68eb3c9b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfbb25eb19adf3b3b40e29957d1fca8"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a9dfbb25eb19adf3b3b40e29957d1fca8">seek</a> (size_t pos)</td></tr>
<tr class="memdesc:a9dfbb25eb19adf3b3b40e29957d1fca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>current pointer</em>.  <a href="#a9dfbb25eb19adf3b3b40e29957d1fca8">More...</a><br /></td></tr>
<tr class="separator:a9dfbb25eb19adf3b3b40e29957d1fca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42c4e25c46d61f7eef4f14aff0db45d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#ab42c4e25c46d61f7eef4f14aff0db45d">cur</a> () const </td></tr>
<tr class="memdesc:ab42c4e25c46d61f7eef4f14aff0db45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <em>current pointer</em>.  <a href="#ab42c4e25c46d61f7eef4f14aff0db45d">More...</a><br /></td></tr>
<tr class="separator:ab42c4e25c46d61f7eef4f14aff0db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ebd0411bea97c24814d8044332d45e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#aa5ebd0411bea97c24814d8044332d45e">size</a> () const </td></tr>
<tr class="memdesc:aa5ebd0411bea97c24814d8044332d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get byte size of data have been written, same as <a class="el" href="classCOutByteStreamBasic.html#ab42c4e25c46d61f7eef4f14aff0db45d">cur</a>.  <a href="#aa5ebd0411bea97c24814d8044332d45e">More...</a><br /></td></tr>
<tr class="separator:aa5ebd0411bea97c24814d8044332d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508228aafedd568248e321b86fd26c77"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a508228aafedd568248e321b86fd26c77">skip</a> (ssize_t off)</td></tr>
<tr class="memdesc:a508228aafedd568248e321b86fd26c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip some bytes.  <a href="#a508228aafedd568248e321b86fd26c77">More...</a><br /></td></tr>
<tr class="separator:a508228aafedd568248e321b86fd26c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcb5c566208dfd74b56a409c9d073c3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#aafcb5c566208dfd74b56a409c9d073c3">skip</a> (ssize_t off, int fill)</td></tr>
<tr class="memdesc:aafcb5c566208dfd74b56a409c9d073c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip some bytes.  <a href="#aafcb5c566208dfd74b56a409c9d073c3">More...</a><br /></td></tr>
<tr class="separator:aafcb5c566208dfd74b56a409c9d073c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa062f3efac0d057a053df7ebea4bcd5e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#aa062f3efac0d057a053df7ebea4bcd5e">toString</a> () const </td></tr>
<tr class="memdesc:aa062f3efac0d057a053df7ebea4bcd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a readable description of this object.  <a href="#aa062f3efac0d057a053df7ebea4bcd5e">More...</a><br /></td></tr>
<tr class="separator:aa062f3efac0d057a053df7ebea4bcd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944b54097f754a3dd27d97e2bc0c52e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a944b54097f754a3dd27d97e2bc0c52e2">finish</a> ()</td></tr>
<tr class="memdesc:a944b54097f754a3dd27d97e2bc0c52e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export data for COutByteStreamStrRef, COutByteStreamVecRef.  <a href="#a944b54097f754a3dd27d97e2bc0c52e2">More...</a><br /></td></tr>
<tr class="separator:a944b54097f754a3dd27d97e2bc0c52e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919cc32ad042279151311aa1bc2631ae"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:a919cc32ad042279151311aa1bc2631ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a919cc32ad042279151311aa1bc2631ae">finish</a> (SizeT *sz)</td></tr>
<tr class="memdesc:a919cc32ad042279151311aa1bc2631ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export data for COutByteStreamBuf, COutByteStreamStrRef, COutByteStreamVecRef.  <a href="#a919cc32ad042279151311aa1bc2631ae">More...</a><br /></td></tr>
<tr class="separator:a919cc32ad042279151311aa1bc2631ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1910025b866aec138912834bef582a82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a1910025b866aec138912834bef582a82">finish</a> (buffer_type &amp;dst)</td></tr>
<tr class="memdesc:a1910025b866aec138912834bef582a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export data for COutByteStream/COutByteStreamStr, COutByteStreamStrRef, COutByteStreamVec, COutByteStreamVecRef.  <a href="#a1910025b866aec138912834bef582a82">More...</a><br /></td></tr>
<tr class="separator:a1910025b866aec138912834bef582a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a964d5a507f05fe6275e0d392b6d38"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; </td></tr>
<tr class="memitem:a03a964d5a507f05fe6275e0d392b6d38"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a03a964d5a507f05fe6275e0d392b6d38">finish</a> (CharT *dst, size_t *sz)</td></tr>
<tr class="memdesc:a03a964d5a507f05fe6275e0d392b6d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export data for COutByteStream/COutByteStreamStr, COutByteStreamStrRef, COutByteStreamVec, COutByteStreamVecRef, COutByteStreamBuf.  <a href="#a03a964d5a507f05fe6275e0d392b6d38">More...</a><br /></td></tr>
<tr class="separator:a03a964d5a507f05fe6275e0d392b6d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pack primitive types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions write <code>c</code> to the underlying buffer, and extend it by <code>sizeof c</code> bytes, with appropriate byte order transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>An integer to be packed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>
</div></td></tr>
<tr class="memitem:ae7e6a771d5c87955ce9e82f8b19b6816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7e6a771d5c87955ce9e82f8b19b6816"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (char c)</td></tr>
<tr class="separator:ae7e6a771d5c87955ce9e82f8b19b6816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c821976b941b03ddf6b334ab5236296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c821976b941b03ddf6b334ab5236296"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (signed char c)</td></tr>
<tr class="separator:a5c821976b941b03ddf6b334ab5236296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace723795a8b5f82fcfa264a3b52f8b3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace723795a8b5f82fcfa264a3b52f8b3f"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (unsigned char c)</td></tr>
<tr class="separator:ace723795a8b5f82fcfa264a3b52f8b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad016d294d381e28770b4fb92db754f26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad016d294d381e28770b4fb92db754f26"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (short c)</td></tr>
<tr class="separator:ad016d294d381e28770b4fb92db754f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac6b19eacc9b548211a4d40cfb23e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac6b19eacc9b548211a4d40cfb23e59"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (unsigned short c)</td></tr>
<tr class="separator:a7ac6b19eacc9b548211a4d40cfb23e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c54f5dee05afe6cdfb8ceaa773716"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae43c54f5dee05afe6cdfb8ceaa773716"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (int c)</td></tr>
<tr class="separator:ae43c54f5dee05afe6cdfb8ceaa773716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44408c7be29fa9dd5d2033fca6aacc5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44408c7be29fa9dd5d2033fca6aacc5b"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (unsigned int c)</td></tr>
<tr class="separator:a44408c7be29fa9dd5d2033fca6aacc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1028571f4748144d9cd0dd8b6eb5a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1028571f4748144d9cd0dd8b6eb5a9"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (long c)</td></tr>
<tr class="separator:aeb1028571f4748144d9cd0dd8b6eb5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53e9057438ef7e4b7000a8af77db575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac53e9057438ef7e4b7000a8af77db575"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (unsigned long c)</td></tr>
<tr class="separator:ac53e9057438ef7e4b7000a8af77db575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5429cccfd40df420b3f3ed110db5e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5429cccfd40df420b3f3ed110db5e0"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (long long c)</td></tr>
<tr class="separator:a7a5429cccfd40df420b3f3ed110db5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae991ff29690d349c2684067c94e4204f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae991ff29690d349c2684067c94e4204f"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (unsigned long long c)</td></tr>
<tr class="separator:ae991ff29690d349c2684067c94e4204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e6e0f3d3a9b047151ed93f2fd30397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e6e0f3d3a9b047151ed93f2fd30397"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (wchar_t c)</td></tr>
<tr class="separator:a63e6e0f3d3a9b047151ed93f2fd30397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pack compound types</div></td></tr>
<tr class="memitem:a54639160c7983fe4831dc4db952c8064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a54639160c7983fe4831dc4db952c8064">operator&lt;&lt;</a> (const std::string &amp;c)</td></tr>
<tr class="memdesc:a54639160c7983fe4831dc4db952c8064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a string.  <a href="#a54639160c7983fe4831dc4db952c8064">More...</a><br /></td></tr>
<tr class="separator:a54639160c7983fe4831dc4db952c8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34364d688168d83d55dcc0eb596234aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#a34364d688168d83d55dcc0eb596234aa">operator&lt;&lt;</a> (const std::wstring &amp;c)</td></tr>
<tr class="memdesc:a34364d688168d83d55dcc0eb596234aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a wide string.  <a href="#a34364d688168d83d55dcc0eb596234aa">More...</a><br /></td></tr>
<tr class="separator:a34364d688168d83d55dcc0eb596234aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c97e4cbc5e3cc23b5752ddd3377742"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:ac1c97e4cbc5e3cc23b5752ddd3377742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html#ac1c97e4cbc5e3cc23b5752ddd3377742">operator&lt;&lt;</a> (const T(&amp;c)[N])</td></tr>
<tr class="memdesc:ac1c97e4cbc5e3cc23b5752ddd3377742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack an array.  <a href="#ac1c97e4cbc5e3cc23b5752ddd3377742">More...</a><br /></td></tr>
<tr class="separator:ac1c97e4cbc5e3cc23b5752ddd3377742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions operates on different manipulators to achieve special purpose.</p>
<p>Please see the corresponding manipulator generators in <a class="el" href="namespaceManip.html">Manip</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Manipulator object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference of self </dd></dl>
</div></td></tr>
<tr class="memitem:aec92cfde06711cea5c9f571ca8de4683"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec92cfde06711cea5c9f571ca8de4683"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aec92cfde06711cea5c9f571ca8de4683"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorRawPtr&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:aec92cfde06711cea5c9f571ca8de4683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba3dc746c3cbb61837f72045b287731"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ba3dc746c3cbb61837f72045b287731"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4ba3dc746c3cbb61837f72045b287731"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorRawCont&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a4ba3dc746c3cbb61837f72045b287731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bf167b211030707ec467e9e8179dab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a73bf167b211030707ec467e9e8179dab"></a>
template&lt;class ForwardIter &gt; </td></tr>
<tr class="memitem:a73bf167b211030707ec467e9e8179dab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorRawRange&lt; ForwardIter &gt; &amp;m)</td></tr>
<tr class="separator:a73bf167b211030707ec467e9e8179dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57036a0c45c7cc1d50799e0577cd6ee4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57036a0c45c7cc1d50799e0577cd6ee4"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a57036a0c45c7cc1d50799e0577cd6ee4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorArrayPtr&lt; LenT, T &gt; &amp;m)</td></tr>
<tr class="separator:a57036a0c45c7cc1d50799e0577cd6ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88a85979c336fd174f604654c6abcde"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad88a85979c336fd174f604654c6abcde"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:ad88a85979c336fd174f604654c6abcde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorArrayCont&lt; LenT, T &gt; &amp;m)</td></tr>
<tr class="separator:ad88a85979c336fd174f604654c6abcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d4269d29842d9a4b2a42b38468d963"><td class="memTemplParams" colspan="2"><a class="anchor" id="a96d4269d29842d9a4b2a42b38468d963"></a>
template&lt;typename LenT , class ForwardIter &gt; </td></tr>
<tr class="memitem:a96d4269d29842d9a4b2a42b38468d963"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorArrayRange&lt; LenT, ForwardIter &gt; &amp;m)</td></tr>
<tr class="separator:a96d4269d29842d9a4b2a42b38468d963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba9b6ad9ac8ba1beb81a2015715ee60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba9b6ad9ac8ba1beb81a2015715ee60"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (void(*m)(__MyBase &amp;))</td></tr>
<tr class="separator:aeba9b6ad9ac8ba1beb81a2015715ee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71a80a610f8f9f7116c17bceefeb9e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b71a80a610f8f9f7116c17bceefeb9e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b71a80a610f8f9f7116c17bceefeb9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorValueByteOrder&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a6b71a80a610f8f9f7116c17bceefeb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aea10fa20d03ef8776bf2a941f404d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aea10fa20d03ef8776bf2a941f404d7"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorSeek &amp;m)</td></tr>
<tr class="separator:a0aea10fa20d03ef8776bf2a941f404d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac596ad79bb5d70e3b5990a6e54d1549e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac596ad79bb5d70e3b5990a6e54d1549e"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorSkip &amp;m)</td></tr>
<tr class="separator:ac596ad79bb5d70e3b5990a6e54d1549e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8600635f106d5108e3121d1ef890fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c8600635f106d5108e3121d1ef890fd"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorSkipFill &amp;m)</td></tr>
<tr class="separator:a8c8600635f106d5108e3121d1ef890fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624ea6ca847a3081915cd61b92d35254"><td class="memTemplParams" colspan="2"><a class="anchor" id="a624ea6ca847a3081915cd61b92d35254"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a624ea6ca847a3081915cd61b92d35254"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorSkipPtr&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a624ea6ca847a3081915cd61b92d35254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d2196bccce44f2f669e73d248e2217"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39d2196bccce44f2f669e73d248e2217"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39d2196bccce44f2f669e73d248e2217"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorSkipPtrFill&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a39d2196bccce44f2f669e73d248e2217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45c0d2386b2748517133ede274f6eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab45c0d2386b2748517133ede274f6eb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aab45c0d2386b2748517133ede274f6eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorOffsetValue&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:aab45c0d2386b2748517133ede274f6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac271b4caeb98e6138129491103932d4f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac271b4caeb98e6138129491103932d4f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac271b4caeb98e6138129491103932d4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorInsert&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:ac271b4caeb98e6138129491103932d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5224e5b5822c10344565839ef116c27"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae5224e5b5822c10344565839ef116c27"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5224e5b5822c10344565839ef116c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorProtobuf&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:ae5224e5b5822c10344565839ef116c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de7eca7d792153400bc8cfca299fa94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4de7eca7d792153400bc8cfca299fa94"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4de7eca7d792153400bc8cfca299fa94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorVarint&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a4de7eca7d792153400bc8cfca299fa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb192883b4c7a419c36b5a6f5cfc5d8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb192883b4c7a419c36b5a6f5cfc5d8b"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorStubPush &amp;m)</td></tr>
<tr class="separator:abb192883b4c7a419c36b5a6f5cfc5d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea785fc66f0bee4308ed8859dc9e970"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abea785fc66f0bee4308ed8859dc9e970"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorStubPop &amp;m)</td></tr>
<tr class="separator:abea785fc66f0bee4308ed8859dc9e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6810e1556530bb4fdc662cab08e183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea6810e1556530bb4fdc662cab08e183"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorEnd&lt; void, void &gt; &amp;m)</td></tr>
<tr class="separator:aea6810e1556530bb4fdc662cab08e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953b35aed6d4335e3f742a14cc095f7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a953b35aed6d4335e3f742a14cc095f7f"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (NS_IMPL::CManipulatorEnd&lt; void, void &gt;(*m)())</td></tr>
<tr class="separator:a953b35aed6d4335e3f742a14cc095f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4c3f9c61853ebba665e0f1a4930c92"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea4c3f9c61853ebba665e0f1a4930c92"></a>
template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:aea4c3f9c61853ebba665e0f1a4930c92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorEnd&lt; SizeT *, void &gt; &amp;m)</td></tr>
<tr class="separator:aea4c3f9c61853ebba665e0f1a4930c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5904a6325647df141b429c1ca25e96ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5904a6325647df141b429c1ca25e96ee"></a>
<a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorEnd&lt; buffer_type, void &gt; &amp;m)</td></tr>
<tr class="separator:a5904a6325647df141b429c1ca25e96ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec535045f92d20d99f1336301ebc8a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaec535045f92d20d99f1336301ebc8a5"></a>
template&lt;typename CharT &gt; </td></tr>
<tr class="memitem:aaec535045f92d20d99f1336301ebc8a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const NS_IMPL::CManipulatorEnd&lt; CharT *, size_t * &gt; &amp;m)</td></tr>
<tr class="separator:aaec535045f92d20d99f1336301ebc8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Data&gt;<br />
class COutByteStreamBasic&lt; Data &gt;</h3>

<p>Data packing interfaces. </p>
<p><a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a> is for easy data packing/encoding/serialization. It manages data <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> automatically, so you don't need to call <code>hton/ntoh</code> family APIs manually. It also performs sufficient boundary checks so you won't end up with memory access violations. <br />
 COutByteStream supports a number of manipulators to operate on compound types and complex structures, which will make your code really concise and efficient. <br />
 The type of underlying byte buffer determines which variant of <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a> you may choose: </p><ul>
<li>Internal <code>std::string</code> </li>
</ul>
<p><code>COutByteStream</code> (or <code>COutByteStreamStr</code>) uses internal <code>std::string</code> as the underlying byte buffer, which means you don't need to provide a byte buffer when constructing a <code>COutByteStream</code> object, instead you could indicate a byte size to the internal <code>std::string</code> object to reserve, so it might not need to expand (and copy data) later on. </p><ul>
<li>External <code>std::string</code> </li>
</ul>
<p>In the contrary, <code>COutByteStreamStrRef</code> needs an external <code>std::string</code> object to store data, provided in the constructor. <code>COutByteStreamStrRef</code> will hold a reference to the <code>std::string</code> object and manipulate it during the process of serialization/encoding. New data will append to the <code>std::string</code> object, so it's possible to deal with some legacy code and avoid performance loss. </p><ul>
<li>Internal <code>std::vector&lt;char&gt;</code> </li>
</ul>
<p>Similar to <code>COutByteStream</code>, <code>COutByteStreamVec</code> uses internal <code>std::vector&lt;char&gt;</code> as the underlying buffer. You can treat them quite the same, and the purpose of <code>COutByteStreamVec</code> is only for completion: some people prefer using <code>std::vector&lt;char&gt;</code> as a buffer. </p><ul>
<li>External <code>std::vector&lt;char&gt;</code> </li>
</ul>
<p><code>COutByteStreamVecRef</code> needs an external <code>std::vector&lt;char&gt;</code> object to construct, just like <code>COutByteStreamStrRef</code> does. And every aspect is just the same for both of them, as described before. </p><ul>
<li>External <code>char</code> array</li>
</ul>
<p><code>COutByteStreamBuf</code> is different from all above. It receives a <code>char</code> array as the underlying buffer, with fixed size, wrapped by <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. It's impossible to <em>expand</em> the underlying buffer, and when it's full, all serialization operations will fail and status is set. <br />
 Here is an example use of <code>COutByteStream:</code> </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;   <span class="comment">// using internal std::string as data buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Following are the data we want to pack</span></div><div class="line">uint32_t version;        <span class="comment">// a 32-bit integer</span></div><div class="line"><span class="keywordtype">string</span> name;             <span class="comment">// a string</span></div><div class="line">vector&lt;uint64_t&gt; orders; <span class="comment">// an array of 64-bit integers</span></div><div class="line"></div><div class="line"><span class="comment">// This is to receive the final data buffer.</span></div><div class="line">std::string buf;</div><div class="line"></div><div class="line"><span class="comment">// Then we serialize all data in ONE line!</span></div><div class="line">out &lt;&lt; version &lt;&lt; name &lt;&lt; Manip::array(orders)</div><div class="line">    &lt;&lt; <a class="code" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a>(buf);  <span class="comment">// And export the data to &#39;buf&#39;</span></div></div><!-- fragment --><p> Other variants are similar, except for the constructors and <a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a> part. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data</td><td>Type of underlying byte buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a> is not intended for direct use, try variants introduced above. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aecf5d35bab5a6cb4d021d98f537f3cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::<a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reserve</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for COutByteStream/COutByteStreamStr, COutByteStreamVec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reserve</td><td>Byte size for the underlying buffer to reserve. </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in the underlying buffer: <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2bce67b3566da7af882d7e1fe062e79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::<a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a> </td>
          <td>(</td>
          <td class="paramtype">buffer_type &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for COutByteStreamStrRef, COutByteStreamVecRef. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Reference to external byte buffer </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in the underlying buffer: <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4769c890371073dcd563698311de1f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::<a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a> </td>
          <td>(</td>
          <td class="paramtype">char_type *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for COutByteStreamBuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to external byte buffer </td></tr>
    <tr><td class="paramname">sz</td><td>Length of <code>buf</code> </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in the underlying buffer: <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a06d94dce28c70e9b6510ba68eb3c9b04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a>&amp; <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::bad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <em>status</em>. </p>
<p>If <em>status</em> is not <code>0</code>, all packing operations will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td><ul>
<li><code>0</code>: Reset status. </li>
<li>Otherwise: A number indicating error status. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference of self </dd></dl>

</div>
</div>
<a class="anchor" id="ab42c4e25c46d61f7eef4f14aff0db45d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::cur </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <em>current pointer</em>. </p>
<p><em>Current pointer</em> is the size of data that have been written to the underlying byte buffer. Every packing operation increases <em>current pointer</em> by the amount of data it writes. </p><dl class="section return"><dt>Returns</dt><dd>Current pointer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCOutByteStreamBasic.html#aa5ebd0411bea97c24814d8044332d45e" title="Get byte size of data have been written, same as cur. ">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a944b54097f754a3dd27d97e2bc0c52e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export data for COutByteStreamStrRef, COutByteStreamVecRef. </p>
<p>Although COutByteStreamStrRef and COutByteStreamVecRef use external byte buffer, it's still necessary to call this function or use <a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end()</a> explicitly, to do some finishing work, e.g. correcting the size of the byte buffer object. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d" title="End operations for CInByteStream, COutByteStreamStrRef, COutByteStreamVecRef. ">Manip::end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a919cc32ad042279151311aa1bc2631ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::finish </td>
          <td>(</td>
          <td class="paramtype">SizeT *&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export data for COutByteStreamBuf, COutByteStreamStrRef, COutByteStreamVecRef. </p>
<p>This function does some finishing work, e.g. correcting the size of the underlying buffer, and return its real size to <code>sz</code>. <br />
 The returned size may be different to <code><a class="el" href="classCOutByteStreamBasic.html#aa5ebd0411bea97c24814d8044332d45e" title="Get byte size of data have been written, same as cur. ">size()</a></code>, in case that there were data already in the external buffer before serialization. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeT</td><td>An integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sz</td><td>Pointer to an integer to receive the size of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d" title="End operations for CInByteStream, COutByteStreamStrRef, COutByteStreamVecRef. ">Manip::end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1910025b866aec138912834bef582a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::finish </td>
          <td>(</td>
          <td class="paramtype">buffer_type &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export data for COutByteStream/COutByteStreamStr, COutByteStreamStrRef, COutByteStreamVec, COutByteStreamVecRef. </p>
<p>This function appends the underlying data to <code>dst</code>. <br />
 For COutByteStream and COutByteStreamVec, if <code>dst</code> is empty before exporting, <code>swap</code> will be used to avoid data copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>A buffer to receive data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d" title="End operations for CInByteStream, COutByteStreamStrRef, COutByteStreamVecRef. ">Manip::end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a03a964d5a507f05fe6275e0d392b6d38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<div class="memtemplate">
template&lt;typename CharT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::finish </td>
          <td>(</td>
          <td class="paramtype">CharT *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export data for COutByteStream/COutByteStreamStr, COutByteStreamStrRef, COutByteStreamVec, COutByteStreamVecRef, COutByteStreamBuf. </p>
<p>This function copies the underlying data to a byte buffer pointed by <code>dst</code>, and returns the real size of data to <code>sz</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Must be the same as the underlying character type, e.g. <code>char</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Pointer to a byte array to receive the data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sz</td><td>Pass in as the length of <code>dst</code>; pass out as the real size of exported data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d" title="End operations for CInByteStream, COutByteStreamStrRef, COutByteStreamVecRef. ">Manip::end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54639160c7983fe4831dc4db952c8064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a>&amp; <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a string. </p>
<p>This function first writes a <code>uint16_t</code> equal to the length of <code>c</code>, then copy the whole string to the underlying buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A string to be packed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a34364d688168d83d55dcc0eb596234aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a>&amp; <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a wide string. </p>
<p>This function first writes a <code>uint16_t</code> equal to the length of <code>c</code>, then copy the whole string to the underlying buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>A wide string to be packed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="ac1c97e4cbc5e3cc23b5752ddd3377742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCOutByteStreamBasic.html">__Myt</a>&amp; <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>c</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack an array. </p>
<p>This function writes <code>N</code> elements directly (without leading length field) to the underlying buffer. <br />
 <code>T</code> must be a type supported by <code>operator &lt;&lt;</code> of <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of element in array </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>An array to be packed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a9dfbb25eb19adf3b3b40e29957d1fca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::seek </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <em>current pointer</em>. </p>
<p>If this function makes <em>current pointer</em> smaller, some data are erased; And if <em>current pointer</em> becomes larger, some room are reserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>New current pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative: Operation failed, <em>status</em> will be set to a nonzero value; </li>
<li>Otherwise: New <em>current pointer</em>; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa5ebd0411bea97c24814d8044332d45e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get byte size of data have been written, same as <a class="el" href="classCOutByteStreamBasic.html#ab42c4e25c46d61f7eef4f14aff0db45d">cur</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Byte size written data </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCOutByteStreamBasic.html#ab42c4e25c46d61f7eef4f14aff0db45d" title="Get current pointer. ">cur</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a508228aafedd568248e321b86fd26c77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip some bytes. </p>
<p>This function is equivalent to <code>seek(<a class="el" href="classCOutByteStreamBasic.html#ab42c4e25c46d61f7eef4f14aff0db45d" title="Get current pointer. ">cur()</a> + off)</code>. If <code>off &gt; 0</code>, some room are reserved; if <code>off &lt; 0</code>, some data are erased. <br />
 The content of the underlying buffer will <em>NOT</em> be modified by this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>Size of bytes to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative: Operation failed, <em>status</em> will be set to a nonzero value; </li>
<li>Otherwise: New <em>current pointer</em>; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aafcb5c566208dfd74b56a409c9d073c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip some bytes. </p>
<p>This function is similar to <code>seek(<a class="el" href="classCOutByteStreamBasic.html#ab42c4e25c46d61f7eef4f14aff0db45d" title="Get current pointer. ">cur()</a> + off)</code>. If <code>off &gt; 0</code>, some room are reserved, and <code>fill</code> are used to fill in the room; if <code>off &lt; 0</code>, some data are erased. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>Size of bytes to skip. </td></tr>
    <tr><td class="paramname">fill</td><td>Character to fill in the reserved room, if any </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative: Operation failed, <em>status</em> will be set to a nonzero value; </li>
<li>Otherwise: New <em>current pointer</em>; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa062f3efac0d057a053df7ebea4bcd5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; Data &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a readable description of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>A readable description of this object </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="data__stream_8hh_source.html">data_stream.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
