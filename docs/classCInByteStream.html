<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Marine Library: CInByteStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marine Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for Linux Networking Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCInByteStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CInByteStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data unpacking interfaces.  
 <a href="classCInByteStream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="data__stream_8hh_source.html">data_stream.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CInByteStream:</div>
<div class="dyncontent">
<div class="center"><img src="classCInByteStream__inherit__graph.png" border="0" usemap="#CInByteStream_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CInByteStream:</div>
<div class="dyncontent">
<div class="center"><img src="classCInByteStream__coll__graph.png" border="0" usemap="#CInByteStream_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad00b8a271fe087e3617572c09683dd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#aad00b8a271fe087e3617572c09683dd2">CInByteStream</a> ()</td></tr>
<tr class="memdesc:aad00b8a271fe087e3617572c09683dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty object.  <a href="#aad00b8a271fe087e3617572c09683dd2">More...</a><br /></td></tr>
<tr class="separator:aad00b8a271fe087e3617572c09683dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cc4c17b6cc68ac1fd8982ed2fda472"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#af1cc4c17b6cc68ac1fd8982ed2fda472">CInByteStream</a> (const char *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:af1cc4c17b6cc68ac1fd8982ed2fda472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a byte buffer.  <a href="#af1cc4c17b6cc68ac1fd8982ed2fda472">More...</a><br /></td></tr>
<tr class="separator:af1cc4c17b6cc68ac1fd8982ed2fda472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d7f3bd9a1caed7763a316e54b4f1ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#ad4d7f3bd9a1caed7763a316e54b4f1ae">CInByteStream</a> (const unsigned char *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:ad4d7f3bd9a1caed7763a316e54b4f1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a byte buffer.  <a href="#ad4d7f3bd9a1caed7763a316e54b4f1ae">More...</a><br /></td></tr>
<tr class="separator:ad4d7f3bd9a1caed7763a316e54b4f1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c64b918052c19b441cf7fbe3503fea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a71c64b918052c19b441cf7fbe3503fea">CInByteStream</a> (const signed char *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:a71c64b918052c19b441cf7fbe3503fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a byte buffer.  <a href="#a71c64b918052c19b441cf7fbe3503fea">More...</a><br /></td></tr>
<tr class="separator:a71c64b918052c19b441cf7fbe3503fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72642e8322a943da6f4aca17dae8b2bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a72642e8322a943da6f4aca17dae8b2bb">CInByteStream</a> (const std::string &amp;buf, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:a72642e8322a943da6f4aca17dae8b2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a byte buffer.  <a href="#a72642e8322a943da6f4aca17dae8b2bb">More...</a><br /></td></tr>
<tr class="separator:a72642e8322a943da6f4aca17dae8b2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d35dec62e832de7486386d187e54776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a9d35dec62e832de7486386d187e54776">setSource</a> (const char *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:a9d35dec62e832de7486386d187e54776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize with a byte buffer.  <a href="#a9d35dec62e832de7486386d187e54776">More...</a><br /></td></tr>
<tr class="separator:a9d35dec62e832de7486386d187e54776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2dbb109f69dc88b241a72c11dbc3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#abf2dbb109f69dc88b241a72c11dbc3d9">setSource</a> (const unsigned char *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:abf2dbb109f69dc88b241a72c11dbc3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize with a byte buffer.  <a href="#abf2dbb109f69dc88b241a72c11dbc3d9">More...</a><br /></td></tr>
<tr class="separator:abf2dbb109f69dc88b241a72c11dbc3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c59e4960401d03425bd6051dd34a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a15c59e4960401d03425bd6051dd34a9a">setSource</a> (const signed char *buf, size_t sz, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:a15c59e4960401d03425bd6051dd34a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize with a byte buffer.  <a href="#a15c59e4960401d03425bd6051dd34a9a">More...</a><br /></td></tr>
<tr class="separator:a15c59e4960401d03425bd6051dd34a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b77e55ff51a3b461ba63ed00a5f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a7f4b77e55ff51a3b461ba63ed00a5f9b">setSource</a> (const std::string &amp;buf, bool net=kByteOrderDefault)</td></tr>
<tr class="memdesc:a7f4b77e55ff51a3b461ba63ed00a5f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize with a byte buffer.  <a href="#a7f4b77e55ff51a3b461ba63ed00a5f9b">More...</a><br /></td></tr>
<tr class="separator:a7f4b77e55ff51a3b461ba63ed00a5f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbfb9e6324db62c6f3618c57c6eb570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a0cbfb9e6324db62c6f3618c57c6eb570">bad</a> (int code)</td></tr>
<tr class="memdesc:a0cbfb9e6324db62c6f3618c57c6eb570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>status</em>.  <a href="#a0cbfb9e6324db62c6f3618c57c6eb570">More...</a><br /></td></tr>
<tr class="separator:a0cbfb9e6324db62c6f3618c57c6eb570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd6632324760504000249749a38e879"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#aadd6632324760504000249749a38e879">seek</a> (size_t pos)</td></tr>
<tr class="memdesc:aadd6632324760504000249749a38e879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>current pointer</em>.  <a href="#aadd6632324760504000249749a38e879">More...</a><br /></td></tr>
<tr class="separator:aadd6632324760504000249749a38e879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750421b7347d599a9bc69cde968186c4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a750421b7347d599a9bc69cde968186c4">skip</a> (ssize_t off)</td></tr>
<tr class="memdesc:a750421b7347d599a9bc69cde968186c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip some data.  <a href="#a750421b7347d599a9bc69cde968186c4">More...</a><br /></td></tr>
<tr class="separator:a750421b7347d599a9bc69cde968186c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19e54f17ae3b9d34892fef290af5bab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#ae19e54f17ae3b9d34892fef290af5bab">cur</a> () const </td></tr>
<tr class="memdesc:ae19e54f17ae3b9d34892fef290af5bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <em>current pointer</em>.  <a href="#ae19e54f17ae3b9d34892fef290af5bab">More...</a><br /></td></tr>
<tr class="separator:ae19e54f17ae3b9d34892fef290af5bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7650c3a3778fbde071482c6ca141be1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#ae7650c3a3778fbde071482c6ca141be1">data</a> () const </td></tr>
<tr class="memdesc:ae7650c3a3778fbde071482c6ca141be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to <em>left</em> data.  <a href="#ae7650c3a3778fbde071482c6ca141be1">More...</a><br /></td></tr>
<tr class="separator:ae7650c3a3778fbde071482c6ca141be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f3a5b61316fab3a2168426cfed21d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#ab6f3a5b61316fab3a2168426cfed21d1">left</a> () const </td></tr>
<tr class="memdesc:ab6f3a5b61316fab3a2168426cfed21d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get byte size of left data.  <a href="#ab6f3a5b61316fab3a2168426cfed21d1">More...</a><br /></td></tr>
<tr class="separator:ab6f3a5b61316fab3a2168426cfed21d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6445508e9ce9eb27e625e50bc7d051"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a4f6445508e9ce9eb27e625e50bc7d051">toString</a> () const </td></tr>
<tr class="memdesc:a4f6445508e9ce9eb27e625e50bc7d051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a readable description of this object.  <a href="#a4f6445508e9ce9eb27e625e50bc7d051">More...</a><br /></td></tr>
<tr class="separator:a4f6445508e9ce9eb27e625e50bc7d051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unpack primitive types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions read <code>sizeof c</code> bytes from underlying data, and store result in <code>c</code>, with appropriate byte order transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>An integer to receive the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>
</div></td></tr>
<tr class="memitem:a8f451aa4ed95b2c5d5af66e98f6b8389"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f451aa4ed95b2c5d5af66e98f6b8389"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (char &amp;c)</td></tr>
<tr class="separator:a8f451aa4ed95b2c5d5af66e98f6b8389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79837e358c3e9bec3a012708fe6124bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79837e358c3e9bec3a012708fe6124bf"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (signed char &amp;c)</td></tr>
<tr class="separator:a79837e358c3e9bec3a012708fe6124bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25112826a71e7abdb7126bbdd2f8b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f25112826a71e7abdb7126bbdd2f8b9"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (unsigned char &amp;c)</td></tr>
<tr class="separator:a1f25112826a71e7abdb7126bbdd2f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93df1d45d82c07dfeb1136ebc2fcba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca93df1d45d82c07dfeb1136ebc2fcba"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (short &amp;c)</td></tr>
<tr class="separator:aca93df1d45d82c07dfeb1136ebc2fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845e501b4e858dbf52e77694b0d76977"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a845e501b4e858dbf52e77694b0d76977"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (unsigned short &amp;c)</td></tr>
<tr class="separator:a845e501b4e858dbf52e77694b0d76977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bc13a053510694d69b42cf8a350548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41bc13a053510694d69b42cf8a350548"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (int &amp;c)</td></tr>
<tr class="separator:a41bc13a053510694d69b42cf8a350548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dcc2221ff5b5fa37b802032eb49a61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52dcc2221ff5b5fa37b802032eb49a61"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (unsigned int &amp;c)</td></tr>
<tr class="separator:a52dcc2221ff5b5fa37b802032eb49a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c928c29e454bbe6f1785b1d3282eb22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c928c29e454bbe6f1785b1d3282eb22"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (long &amp;c)</td></tr>
<tr class="separator:a1c928c29e454bbe6f1785b1d3282eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e0a55aefb38dce769d003dce5381d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e0a55aefb38dce769d003dce5381d9"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (unsigned long &amp;c)</td></tr>
<tr class="separator:aa8e0a55aefb38dce769d003dce5381d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff23eac9e92347a8d8b7de085f07bef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff23eac9e92347a8d8b7de085f07bef"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (long long &amp;c)</td></tr>
<tr class="separator:a6ff23eac9e92347a8d8b7de085f07bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d344417e3ee4a16bc2e38b2187b57c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d344417e3ee4a16bc2e38b2187b57c1"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (unsigned long long &amp;c)</td></tr>
<tr class="separator:a7d344417e3ee4a16bc2e38b2187b57c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea7429316bf4ab3c767328957e9c6a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea7429316bf4ab3c767328957e9c6a7"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (wchar_t &amp;c)</td></tr>
<tr class="separator:a9ea7429316bf4ab3c767328957e9c6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unpack compound types</div></td></tr>
<tr class="memitem:a74716d946288c49177072d88e853f2fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a74716d946288c49177072d88e853f2fc">operator&gt;&gt;</a> (std::string &amp;c)</td></tr>
<tr class="memdesc:a74716d946288c49177072d88e853f2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a string.  <a href="#a74716d946288c49177072d88e853f2fc">More...</a><br /></td></tr>
<tr class="separator:a74716d946288c49177072d88e853f2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6383aac9241149bb21f86225f6e537bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a6383aac9241149bb21f86225f6e537bf">operator&gt;&gt;</a> (std::wstring &amp;c)</td></tr>
<tr class="memdesc:a6383aac9241149bb21f86225f6e537bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a wide string.  <a href="#a6383aac9241149bb21f86225f6e537bf">More...</a><br /></td></tr>
<tr class="separator:a6383aac9241149bb21f86225f6e537bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e138462535db8e8425f644c2f0898f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a10e138462535db8e8425f644c2f0898f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCInByteStream.html#a10e138462535db8e8425f644c2f0898f">operator&gt;&gt;</a> (T(&amp;c)[N])</td></tr>
<tr class="memdesc:a10e138462535db8e8425f644c2f0898f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack an array.  <a href="#a10e138462535db8e8425f644c2f0898f">More...</a><br /></td></tr>
<tr class="separator:a10e138462535db8e8425f644c2f0898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions operates on different manipulators to achieve special purpose.</p>
<p>Please see the corresponding manipulator generators in <a class="el" href="namespaceManip.html">Manip</a> for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Manipulator object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference of self </dd></dl>
</div></td></tr>
<tr class="memitem:ad2d89f75f84089df9fd0030ea0d38e11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d89f75f84089df9fd0030ea0d38e11"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (void(*m)(__MyBase &amp;))</td></tr>
<tr class="separator:ad2d89f75f84089df9fd0030ea0d38e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6abc0b23eb2f2b45816dd7eed6338f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada6abc0b23eb2f2b45816dd7eed6338f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ada6abc0b23eb2f2b45816dd7eed6338f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorRawPtr&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:ada6abc0b23eb2f2b45816dd7eed6338f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6673f4f456402afc9f59708100ebd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd6673f4f456402afc9f59708100ebd7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abd6673f4f456402afc9f59708100ebd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorRawCont&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:abd6673f4f456402afc9f59708100ebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58d0839d58e305f70aa6b0f91e08186"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad58d0839d58e305f70aa6b0f91e08186"></a>
template&lt;class ForwardIter &gt; </td></tr>
<tr class="memitem:ad58d0839d58e305f70aa6b0f91e08186"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorRawRange&lt; ForwardIter &gt; &amp;m)</td></tr>
<tr class="separator:ad58d0839d58e305f70aa6b0f91e08186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4125821bff8d6479bc7ef1f8bcf560aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4125821bff8d6479bc7ef1f8bcf560aa"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a4125821bff8d6479bc7ef1f8bcf560aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorArrayPtr&lt; LenT, T &gt; &amp;m)</td></tr>
<tr class="separator:a4125821bff8d6479bc7ef1f8bcf560aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf90a15613c935d2436e737d6ba5aa45"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf90a15613c935d2436e737d6ba5aa45"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:abf90a15613c935d2436e737d6ba5aa45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorArrayCont&lt; LenT, T &gt; &amp;m)</td></tr>
<tr class="separator:abf90a15613c935d2436e737d6ba5aa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05c44b70fb5b26f6ea9678777eda5f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab05c44b70fb5b26f6ea9678777eda5f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab05c44b70fb5b26f6ea9678777eda5f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorValueByteOrder&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:ab05c44b70fb5b26f6ea9678777eda5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f939082a72b4447775794358000794d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f939082a72b4447775794358000794d"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorSeek &amp;m)</td></tr>
<tr class="separator:a5f939082a72b4447775794358000794d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4f1c03b987cc594439368100ee273e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d4f1c03b987cc594439368100ee273e"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorSkip &amp;m)</td></tr>
<tr class="separator:a5d4f1c03b987cc594439368100ee273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af112b515d27e2ed5620a714190f9f130"><td class="memTemplParams" colspan="2"><a class="anchor" id="af112b515d27e2ed5620a714190f9f130"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af112b515d27e2ed5620a714190f9f130"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorSkipPtr&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:af112b515d27e2ed5620a714190f9f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d2695d9a0f3cc02b30bc8d69230737"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86d2695d9a0f3cc02b30bc8d69230737"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a86d2695d9a0f3cc02b30bc8d69230737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorOffsetValue&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a86d2695d9a0f3cc02b30bc8d69230737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac3428fb5e1de2d19ee903c3ff77078"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaac3428fb5e1de2d19ee903c3ff77078"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaac3428fb5e1de2d19ee903c3ff77078"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorProtobuf&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:aaac3428fb5e1de2d19ee903c3ff77078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca69a1f48ca459b51098a14a36e2bb2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ca69a1f48ca459b51098a14a36e2bb2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ca69a1f48ca459b51098a14a36e2bb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorVarint&lt; T &gt; &amp;m)</td></tr>
<tr class="separator:a8ca69a1f48ca459b51098a14a36e2bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080962eec17adfbbffafa6348d2c7ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa080962eec17adfbbffafa6348d2c7ed"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorStubPush &amp;m)</td></tr>
<tr class="separator:aa080962eec17adfbbffafa6348d2c7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd3305e14a4d966a7dfc37000dee0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7fd3305e14a4d966a7dfc37000dee0e"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorStubPop &amp;m)</td></tr>
<tr class="separator:aa7fd3305e14a4d966a7dfc37000dee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db656642a0b8639a236bc73f974eee5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7db656642a0b8639a236bc73f974eee5"></a>
template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:a7db656642a0b8639a236bc73f974eee5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const NS_IMPL::CManipulatorEnd&lt; T, S &gt; &amp;m)</td></tr>
<tr class="separator:a7db656642a0b8639a236bc73f974eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0713ac1eb21ee0e44cc81fbebe87c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0713ac1eb21ee0e44cc81fbebe87c8"></a>
<a class="el" href="classCInByteStream.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (NS_IMPL::CManipulatorEnd&lt; void, void &gt;(*m)())</td></tr>
<tr class="separator:a0c0713ac1eb21ee0e44cc81fbebe87c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data unpacking interfaces. </p>
<p><a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> is super convenient for unpacking data. It receives a byte buffer containing serialized data, and tries to decode whatever you want from it. <br />
 <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> manages data <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> automatically, so you don't need to call <code>hton/ntoh</code> family APIs manually.It also performs sufficient boundary checks so you won't end up with memory access violations. <br />
 What makes <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> really powerful is that it integrates a number of manipulators, which makes unpacking complex structures a joy of life. <br />
 Sample code: </p><div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);   <span class="comment">// initialize from a byte buffer</span></div><div class="line"></div><div class="line"><span class="comment">// Following are the data we want to unpack</span></div><div class="line">uint32_t version;        <span class="comment">// a 32-bit integer</span></div><div class="line"><span class="keywordtype">string</span> name;             <span class="comment">// a string</span></div><div class="line">vector&lt;uint64_t&gt; orders; <span class="comment">// an array of 64-bit integers</span></div><div class="line"></div><div class="line"><span class="comment">// Then we extract all data in ONE line!</span></div><div class="line">in &gt;&gt; version &gt;&gt; name &gt;&gt; Manip::array(orders);</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aad00b8a271fe087e3617572c09683dd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CInByteStream::CInByteStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty object. </p>
<p>You need to call <a class="el" href="classCInByteStream.html#a9d35dec62e832de7486386d187e54776">setSource</a> before you can use this object to unpack data. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classCInByteStream.html#a9d35dec62e832de7486386d187e54776" title="Initialize with a byte buffer. ">setSource</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1cc4c17b6cc68ac1fd8982ed2fda472"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CInByteStream::CInByteStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of <code>buf</code>, if present </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4d7f3bd9a1caed7763a316e54b4f1ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CInByteStream::CInByteStream </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of <code>buf</code>, if present </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71c64b918052c19b441cf7fbe3503fea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CInByteStream::CInByteStream </td>
          <td>(</td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of <code>buf</code> </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72642e8322a943da6f4aca17dae8b2bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CInByteStream::CInByteStream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0cbfb9e6324db62c6f3618c57c6eb570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCInByteStream.html">__Myt</a>&amp; CInByteStream::bad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <em>status</em>. </p>
<p>If <em>status</em> is not <code>0</code>, all unpacking operations will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td><ul>
<li><code>0</code>: Reset status. </li>
<li>Otherwise: A number indicating error status. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference of self </dd></dl>

</div>
</div>
<a class="anchor" id="ae19e54f17ae3b9d34892fef290af5bab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CInByteStream::cur </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <em>current pointer</em>. </p>
<p><em>Current pointer</em> is the index of underlying data where next unpacking operation will take place. Every unpacking operation increases <em>current pointer</em> by the amount of data it reads. </p><dl class="section return"><dt>Returns</dt><dd>Current pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ae7650c3a3778fbde071482c6ca141be1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* CInByteStream::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to <em>left</em> data. </p>
<p>This function returns a pointer to the first unread byte, which is also indicated by <em>current pointer</em>. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the unread data </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCInByteStream.html#ae19e54f17ae3b9d34892fef290af5bab" title="Get current pointer. ">cur</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6f3a5b61316fab3a2168426cfed21d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CInByteStream::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get byte size of left data. </p>
<p>If there are stubs, this function returns data size <em>before</em> current effective stub. </p><dl class="section return"><dt>Returns</dt><dd>Bytes size of left data </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4" title="Set up a stub. ">Manip::stub</a> Mapip::stub_pop </dd></dl>

</div>
</div>
<a class="anchor" id="a74716d946288c49177072d88e853f2fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCInByteStream.html">__Myt</a>&amp; CInByteStream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a string. </p>
<p>This function first reads a <code>uint16_t</code> as the length of the result string, then reads the whole string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>A string to receive the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a6383aac9241149bb21f86225f6e537bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCInByteStream.html">__Myt</a>&amp; CInByteStream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::wstring &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a wide string. </p>
<p>This function first reads a <code>uint16_t</code> as the length of the result wide string, then reads the whole wide string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>A wide string to receive the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a10e138462535db8e8425f644c2f0898f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCInByteStream.html">__Myt</a>&amp; CInByteStream::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>c</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack an array. </p>
<p>This function reads <code>N</code> elements directly (without leading length field), and stores them in <code>c</code>. <br />
 <code>T</code> must be a type supported by <code>operator &gt;&gt;</code> of <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of element in array </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>An array to receive the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="aadd6632324760504000249749a38e879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t CInByteStream::seek </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <em>current pointer</em>. </p>
<p>If this function makes <em>current pointer</em> smaller, old data will be read again; And if <em>current pointer</em> becomes larger, some data will be skipped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>New current pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative: Operation failed, <em>status</em> will be set to a nonzero value; </li>
<li>Otherwise: New <em>current pointer</em>; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9d35dec62e832de7486386d187e54776"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CInByteStream::setSource </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize with a byte buffer. </p>
<p>This function will also reset current pointer and status. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of <code>buf</code>, if present </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf2dbb109f69dc88b241a72c11dbc3d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CInByteStream::setSource </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize with a byte buffer. </p>
<p>This function will also reset current pointer and status. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of <code>buf</code>, if present </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15c59e4960401d03425bd6051dd34a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CInByteStream::setSource </td>
          <td>(</td>
          <td class="paramtype">const signed char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize with a byte buffer. </p>
<p>This function will also reset <em>current pointer</em> (current reading position) and <em>status</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of <code>buf</code>, if present </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f4b77e55ff51a3b461ba63ed00a5f9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CInByteStream::setSource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>net</em> = <code>kByteOrderDefault</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize with a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A byte buffer containing data to be unpacked </td></tr>
    <tr><td class="paramname">net</td><td>Byte order of the data in <code>buf:</code> <ul>
<li><code>true:</code> Net byte order, this is the default; </li>
<li><code>false:</code> Host byte order; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a750421b7347d599a9bc69cde968186c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t CInByteStream::skip </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip some data. </p>
<p>This function is equivalent to <code>seek(<a class="el" href="classCInByteStream.html#ae19e54f17ae3b9d34892fef290af5bab" title="Get current pointer. ">cur()</a> + off)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>Bytes size of data to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative: Operation failed, <em>status</em> will be set to a nonzero value; </li>
<li>Otherwise: New <em>current pointer</em>; </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You can also give a negative <code>off</code> to jump back to old data. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f6445508e9ce9eb27e625e50bc7d051"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CInByteStream::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a readable description of this object. </p>
<dl class="section return"><dt>Returns</dt><dd>A readable description of this object </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="data__stream_8hh_source.html">data_stream.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
