<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Marine Library: data_stream.hh File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marine Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for Linux Networking Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8f88634022b2fc9e8bb020a4d4f478ba.html">marine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">data_stream.hh File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data packing library using stream style interfaces.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="data__stream__impl_8hh_source.html">impl/data_stream_impl.hh</a>&quot;</code><br />
</div>
<p><a href="data__stream_8hh_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCInByteStream.html">CInByteStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data unpacking interfaces.  <a href="classCInByteStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic&lt; Data &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data packing interfaces.  <a href="classCOutByteStreamBasic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceManip"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html">Manip</a></td></tr>
<tr class="memdesc:namespaceManip"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manipulators for stream interface APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0ef01e09d25bd19584df091684fd736c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; NS_IMPL::__buf_data&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a></td></tr>
<tr class="memdesc:a0ef01e09d25bd19584df091684fd736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use internal <code>std::string</code> as the underlying data buffer.  <a href="#a0ef01e09d25bd19584df091684fd736c">More...</a><br /></td></tr>
<tr class="separator:a0ef01e09d25bd19584df091684fd736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c079c52e5385473976281ce00251ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c079c52e5385473976281ce00251ab"></a>
typedef <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a></td></tr>
<tr class="memdesc:a47c079c52e5385473976281ce00251ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as COutByteStreamStr. <br /></td></tr>
<tr class="separator:a47c079c52e5385473976281ce00251ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8437a5fc88be591f9b1525fff60ccc82"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; NS_IMPL::__buf_ref_data&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a></td></tr>
<tr class="memdesc:a8437a5fc88be591f9b1525fff60ccc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use external <code>std::string</code> as the underlying data buffer.  <a href="#a8437a5fc88be591f9b1525fff60ccc82">More...</a><br /></td></tr>
<tr class="separator:a8437a5fc88be591f9b1525fff60ccc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bd78a8893b4db9e628d4c8f1996057"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; NS_IMPL::__buf_data&lt; std::vector&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a></td></tr>
<tr class="memdesc:ad8bd78a8893b4db9e628d4c8f1996057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use internal <code>std::vector&lt;char&gt;</code> as the underlying data buffer.  <a href="#ad8bd78a8893b4db9e628d4c8f1996057">More...</a><br /></td></tr>
<tr class="separator:ad8bd78a8893b4db9e628d4c8f1996057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39d48292420eb915840ecb1b005fece"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; NS_IMPL::__buf_ref_data&lt; std::vector&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a></td></tr>
<tr class="memdesc:af39d48292420eb915840ecb1b005fece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use external <code>std::vector&lt;char&gt;</code> as the underlying data buffer.  <a href="#af39d48292420eb915840ecb1b005fece">More...</a><br /></td></tr>
<tr class="separator:af39d48292420eb915840ecb1b005fece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6d169189f59f48cb8b8c19cea19b26"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt; NS_IMPL::__buf_data&lt; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a></td></tr>
<tr class="memdesc:afb6d169189f59f48cb8b8c19cea19b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use external <code>char</code> array as the underlying data buffer.  <a href="#afb6d169189f59f48cb8b8c19cea19b26">More...</a><br /></td></tr>
<tr class="separator:afb6d169189f59f48cb8b8c19cea19b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorProtobuf&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e">Manip::protobuf</a> (T &amp;msg, size_t size=size_t(-1))</td></tr>
<tr class="memdesc:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack/unpack <a href="https://github.com/google/protobuf">Protocol Buffers</a> messages.  <a href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e">More...</a><br /></td></tr>
<tr class="separator:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181b437b00e3fabbfa66b62a778561f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab181b437b00e3fabbfa66b62a778561f"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorVarint&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#ab181b437b00e3fabbfa66b62a778561f">Manip::varint</a> (const T &amp;val)</td></tr>
<tr class="memdesc:ab181b437b00e3fabbfa66b62a778561f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack integer using <a href="http://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a> encoding.  <a href="namespaceManip.html#ab181b437b00e3fabbfa66b62a778561f">More...</a><br /></td></tr>
<tr class="separator:ab181b437b00e3fabbfa66b62a778561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac625510fbd47e955faa40fbcff1a8496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac625510fbd47e955faa40fbcff1a8496"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorVarint&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#ac625510fbd47e955faa40fbcff1a8496">Manip::varint</a> (T &amp;val)</td></tr>
<tr class="memdesc:ac625510fbd47e955faa40fbcff1a8496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack integer using <a href="http://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a> encoding.  <a href="namespaceManip.html#ac625510fbd47e955faa40fbcff1a8496">More...</a><br /></td></tr>
<tr class="separator:ac625510fbd47e955faa40fbcff1a8496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9007b4269e679af40fa9f5da3ad07ca4"><td class="memItemLeft" align="right" valign="top">NS_IMPL::CManipulatorStubPush&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">Manip::stub</a> (size_t sz)</td></tr>
<tr class="memdesc:a9007b4269e679af40fa9f5da3ad07ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a stub.  <a href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">More...</a><br /></td></tr>
<tr class="separator:a9007b4269e679af40fa9f5da3ad07ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3e0d1f84519db6f53f6e77ed5eb22b"><td class="memItemLeft" align="right" valign="top">NS_IMPL::CManipulatorStubPop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a4d3e0d1f84519db6f53f6e77ed5eb22b">Manip::stub_pop</a> (bool align=false, bool check=false)</td></tr>
<tr class="memdesc:a4d3e0d1f84519db6f53f6e77ed5eb22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demolish the top most stub.  <a href="namespaceManip.html#a4d3e0d1f84519db6f53f6e77ed5eb22b">More...</a><br /></td></tr>
<tr class="separator:a4d3e0d1f84519db6f53f6e77ed5eb22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapip::raw</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Pack/unpack a range of elements, <em>without</em> leading size field.</p>
<p><code>Mapip::raw</code> is convenient for pack/unpack fixed number of elements, like an array, a string of characters, or a container. </p><dl class="section user"><dt>Array</dt><dd>Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[5];    <span class="comment">// an array to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c);  <span class="comment">// unpack 5 integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; 5;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[5];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c);    <span class="comment">// pack 5 integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; 5;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> If size of array cannot be deduced automatically, a parameter must be provided. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];    <span class="comment">// an array to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, sz);  <span class="comment">// unpack &#39;sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c, sz);    <span class="comment">// pack &#39;sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Containers</dt><dd>Most STL containers are well supported, e.g. <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set/multiset</code>, <code>map/multimap</code>, etc. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// a container to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, sz);  <span class="comment">// unpack &#39;sz&#39; integers, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0, v;i &lt; sz;++i){</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.insert(c.end(), v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// an vector to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c);    <span class="comment">// pack all elements in &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>String</dt><dd>A C-style string is essentially an array of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> * c = <span class="keyword">new</span> <span class="keywordtype">char</span>[sz];    <span class="comment">// an array of chars to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, sz);  <span class="comment">// unpack &#39;sz&#39; chars</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a C-style string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c, strlen(c));    <span class="comment">// pack a C-style string</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; strlen(c);++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> <br />
 An <code>std::string</code> is a container of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c;    <span class="comment">// an object to receive unpacked data</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, len);  <span class="comment">// unpack &#39;len&#39; bytes of data, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; len;++i){</span></div><div class="line"><span class="comment">//     char v;</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.push_back(v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c);    <span class="comment">// pack the string</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Iterator range</dt><dd>Sometimes you only have a begin and an end iterators to do the packing/unpacking. A <code>size_t *</code> parameter might be provided to retrieve the number of elements actually packed/unpacked. If it doesn't matter, just ignore it. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">list&lt;int&gt; c;</div><div class="line">list&lt;int&gt;::iterator first = c.begin();  <span class="comment">// start iterator</span></div><div class="line">list&lt;int&gt;::iterator last = c.end();     <span class="comment">// end iterator</span></div><div class="line"><span class="keywordtype">size_t</span> sz;</div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(first, last, &amp;sz);  <span class="comment">// unpack certain integers to range [first, last), and</span></div><div class="line">                                     <span class="comment">// store the number of elements unpaced in &#39;sz&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(list&lt;int&gt;::iterator it = first;it != last;++it)</span></div><div class="line"><span class="comment">//     in &gt;&gt; *it;</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">list&lt;int&gt; c;</div><div class="line">list&lt;int&gt;::const_iterator first = c.begin();  <span class="comment">// start iterator</span></div><div class="line">list&lt;int&gt;::const_iterator last = c.end();     <span class="comment">// end iterator</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(first, last);  <span class="comment">// pack certain integers from range [first, last), not</span></div><div class="line">                                 <span class="comment">// interested in the number of elements packed</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(list&lt;int&gt;::const_iterator it = first;it != last;++it)</span></div><div class="line"><span class="comment">//     out &lt;&lt; *it;</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:ab85bcd346ad33876acd996432ca54e73"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab85bcd346ad33876acd996432ca54e73"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:ab85bcd346ad33876acd996432ca54e73"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (T(&amp;c)[N])</td></tr>
<tr class="separator:ab85bcd346ad33876acd996432ca54e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ae085e46b34b6585fa3cbc24e77b37"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae6ae085e46b34b6585fa3cbc24e77b37"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae6ae085e46b34b6585fa3cbc24e77b37"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (T *c, size_t sz)</td></tr>
<tr class="separator:ae6ae085e46b34b6585fa3cbc24e77b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d825102aad20360a0c38ab071986969"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d825102aad20360a0c38ab071986969"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d825102aad20360a0c38ab071986969"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (std::vector&lt; T &gt; &amp;c, size_t sz)</td></tr>
<tr class="separator:a6d825102aad20360a0c38ab071986969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5576194348c8f9a4d39c3ab31588796c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5576194348c8f9a4d39c3ab31588796c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5576194348c8f9a4d39c3ab31588796c"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (const std::vector&lt; T &gt; &amp;c, size_t *sz=NULL)</td></tr>
<tr class="separator:a5576194348c8f9a4d39c3ab31588796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f584c43cd3f3cb80ea4cf740cbf15"><td class="memTemplParams" colspan="2"><a class="anchor" id="a154f584c43cd3f3cb80ea4cf740cbf15"></a>
template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a154f584c43cd3f3cb80ea4cf740cbf15"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; Char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (std::basic_string&lt; Char &gt; &amp;c, size_t len)</td></tr>
<tr class="separator:a154f584c43cd3f3cb80ea4cf740cbf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca62b8f5e33e710a85846d814763ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1bca62b8f5e33e710a85846d814763ce"></a>
template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a1bca62b8f5e33e710a85846d814763ce"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; const Char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (const std::basic_string&lt; Char &gt; &amp;c, size_t *sz=NULL)</td></tr>
<tr class="separator:a1bca62b8f5e33e710a85846d814763ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e0cbaf0a71fb7e67a0e7d6424fc87"><td class="memTemplParams" colspan="2"><a class="anchor" id="a423e0cbaf0a71fb7e67a0e7d6424fc87"></a>
template&lt;class ForwardIter &gt; </td></tr>
<tr class="memitem:a423e0cbaf0a71fb7e67a0e7d6424fc87"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawRange&lt; ForwardIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (ForwardIter first, ForwardIter last, size_t *sz=NULL)</td></tr>
<tr class="separator:a423e0cbaf0a71fb7e67a0e7d6424fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286a48755fb37057515deb0f1555799a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a286a48755fb37057515deb0f1555799a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a286a48755fb37057515deb0f1555799a"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawCont&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (T &amp;c, size_t sz)</td></tr>
<tr class="separator:a286a48755fb37057515deb0f1555799a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528bd13e2fe97161ff1e717a12d574f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a528bd13e2fe97161ff1e717a12d574f4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a528bd13e2fe97161ff1e717a12d574f4"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawCont&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::raw</b> (const T &amp;c, size_t *sz=NULL)</td></tr>
<tr class="separator:a528bd13e2fe97161ff1e717a12d574f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapip::array</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Pack/unpack a range of elements, <em>with</em> leading size field.</p>
<p><code>Mapip::array</code> is convenient for pack/unpack a number of elements, like an array, a string of characters, or a container. It is very similar to <code>Manip::raw</code>, except that a size field (the number elements) is packed/unpacked first before the elements. By default, the type of leading size field is <code>uint16_t</code>, unless you specify it explicitly. </p><dl class="section user"><dt>Array</dt><dd>Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[10];   <span class="comment">// an array to receive unpacked results</span></div><div class="line">uint8_t sz;  <span class="comment">// an integer to retrieve the number of elements actually unpacked</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c, &amp;sz);  <span class="comment">// firstly unpack an uint8_t to &#39;sz&#39; as the number of following</span></div><div class="line">                             <span class="comment">// elements, then unpack &#39;sz&#39; integers to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// in &gt;&gt; sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Note that if <code>sz</code> is larger than the size <code>c</code> can hold, the whole operation fails with status of <code>in</code> set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[5];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint16_t&gt;(c);   <span class="comment">// pack a uint16_t equals to 5, then pack 5 integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(5);</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; 5;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that you <em>must</em> specify the type of leading size. <br />
 If size of array cannot be deduced automatically, a parameter must be provided. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];   <span class="comment">// an array to receive unpacked results</span></div><div class="line">uint16_t real_sz;        <span class="comment">// an integer to retrieve the number of elements actually unpacked</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c, sz, &amp;real_sz);<span class="comment">// firstly unpack a uin16_t to &#39;real_sz&#39; as the number of</span></div><div class="line">                                    <span class="comment">// following elements, then unpack &#39;real_sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// in &gt;&gt; real_sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; real_sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Note that if <code>real_sz</code> is larger than <code>sz</code>, the whole operation fails with status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint16_t&gt;(c, sz);    <span class="comment">// pack a uint16_t equals to &#39;sz&#39; first, then pack</span></div><div class="line">                                         <span class="comment">// &#39;sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(sz);</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that you <em>must</em> specify the type of leading size. </dd></dl>
<dl class="section user"><dt>Containers</dt><dd>Most STL containers are well supported, e.g. <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set/multiset</code>, <code>map/multimap</code>, etc. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// a container to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c);  <span class="comment">// firstly unpack a uint16_t as the number of following elements,</span></div><div class="line">                        <span class="comment">// then unpack that number of integers, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// uint16_t sz;</span></div><div class="line"><span class="comment">// in &gt;&gt; sz;</span></div><div class="line"><span class="comment">// for(int i = 0, v;i &lt; sz;++i){</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.insert(c.end(), v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> If the leading size is not <code>uint16_t</code>, you can specify it like this: <div class="fragment"><div class="line">in &gt;&gt; Mapip::array&lt;uint8_t&gt;(c);  <span class="comment">// firstly unpack a uint8_t as the number of following</span></div><div class="line">                                 <span class="comment">// elements, then unpack that number of integers, and</span></div><div class="line">                                 <span class="comment">// append them to &#39;c&#39;</span></div></div><!-- fragment --> If there is a limitation of elements, an additional parameter may be provided, and the leading size has the same type as the second parameter: <div class="fragment"><div class="line">uint32_t max_sz = 100;</div><div class="line">in &gt;&gt; Mapip::array(c, max_sz);   <span class="comment">// firstly unpack a uint32_t as the number of following</span></div><div class="line">                                 <span class="comment">// elements, then unpack that number of integers, and</span></div><div class="line">                                 <span class="comment">// append them to &#39;c&#39;</span></div></div><!-- fragment --> If the leading size unpacked is larger than <code>max_sz</code>, the operation fails and status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// an vector to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array(c);  <span class="comment">// firstly pack a uint16_t equals to &#39;c.size()&#39;, then pack all</span></div><div class="line">                         <span class="comment">// elements in &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(c.size());</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that you can specify the type of leading size like this: <div class="fragment"><div class="line">out &lt;&lt; Mapip::array&lt;uint8_t&gt;(c); <span class="comment">// firstly pack a uint8_t equals to &#39;c.size()&#39;, then pack</span></div><div class="line">                                 <span class="comment">//all elements in &#39;c&#39;</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>String</dt><dd>A C-style string is essentially an array of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> * c = <span class="keyword">new</span> <span class="keywordtype">char</span>[sz]; <span class="comment">// an array of chars to receive unpacked results</span></div><div class="line">uint16_t real_sz;        <span class="comment">// an integer to retrieve the number characters actually unpacked</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c, sz, &amp;real_sz);  <span class="comment">// firstly unpack a uint16_t to &#39;real_sz&#39; as the</span></div><div class="line">                                      <span class="comment">// number of following characters, then unpack</span></div><div class="line">                                      <span class="comment">// &#39;real_sz&#39; characters to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// in &gt;&gt; real_sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; real_sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> If <code>real_sz</code> is larger than <code>sz</code>, this operation fails and status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a C-style string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint8_t&gt;(c, strlen(c));    <span class="comment">// firstly pack a uint8_t equals to</span></div><div class="line">                                               <span class="comment">// &#39;strlen(c)&#39;, then pack the content of &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint8_t(strlen(c));</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; strlen(c);++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that the type of leading size <em>must</em> be provided. <br />
 An <code>std::string</code> is a container of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c;    <span class="comment">// an object to receive unpacked data</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c);  <span class="comment">// firstly unpack a uint16_t as the number of following characters,</span></div><div class="line">                        <span class="comment">// then unpack that number of bytes of data, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// uint16_t sz;</span></div><div class="line"><span class="comment">// in &gt;&gt; sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i){</span></div><div class="line"><span class="comment">//     char v;</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.push_back(v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> You can specify the type of leading size like this: <div class="fragment"><div class="line">in &gt;&gt; Mapip::array&lt;uint8_t&gt;(c);  <span class="comment">// firstly unpack a uint8_t as the number of following</span></div><div class="line">                                 <span class="comment">// characters, then unpack that number of bytes of data,</span></div><div class="line">                                 <span class="comment">// and append them to &#39;c&#39;</span></div></div><!-- fragment --> If there is a limitation of bytes to unpack, an additional parameter may be provided, and the type of leading size is the same as the second parameter: <div class="fragment"><div class="line">uint8_t max_sz = 100;</div><div class="line">in &gt;&gt; Mapip::array(c, max_sz);   <span class="comment">// firstly unpack a uint8_t as the number of following</span></div><div class="line">                                 <span class="comment">// characters, then unpack that number of bytes of data,</span></div><div class="line">                                 <span class="comment">// and append them to &#39;c&#39;</span></div></div><!-- fragment --> If the leading size unpacked is larger than <code>max_sz</code>, the operation fails and status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array(c);  <span class="comment">// firstly pack a uint16_t equals to &#39;c.size()&#39;, then pack the</span></div><div class="line">                         <span class="comment">// content of &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(c.size());</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> If the type of leading size isn't <code>uint16_t</code>, you can specify it like this: <div class="fragment"><div class="line">out &lt;&lt; Mapip::array&lt;uint8_t&gt;(c); <span class="comment">// firstly pack a uint8_t equals to &#39;c.size()&#39;, then pack</span></div><div class="line">                                 <span class="comment">// the content of &#39;c&#39;</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Iterator range (pack only)</dt><dd>Sometimes you only have a begin and an end iterators to do the packing. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">list&lt;int&gt; c;</div><div class="line">list&lt;int&gt;::const_iterator first = c.begin();  <span class="comment">// start iterator</span></div><div class="line">list&lt;int&gt;::const_iterator last = c.end();     <span class="comment">// end iterator</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint16_t&gt;(first, last);<span class="comment">// firstly pack a uint16_t equals to the number of</span></div><div class="line">                                           <span class="comment">// elements in range [first, last), then pack all</span></div><div class="line">                                           <span class="comment">// integers the range</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(distance(first, last));</span></div><div class="line"><span class="comment">// for(list&lt;int&gt;::const_iterator it = first;it != last;++it)</span></div><div class="line"><span class="comment">//     out &lt;&lt; *it;</span></div></div><!-- fragment --> An additional integer parameter could be provided to retrieve the number of elements packed, and it will have the same type of the leading size: <div class="fragment"><div class="line">uint8_t sz;</div><div class="line">out &lt;&lt; Mapip::array(first, last, &amp;sz);   <span class="comment">// firstly pack a uint8_t equals to the number of</span></div><div class="line">                                         <span class="comment">// elements in range [first, last), then pack all</span></div><div class="line">                                         <span class="comment">// integers in the range</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a4e99d69171c39ace6c3e79620a595158"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e99d69171c39ace6c3e79620a595158"></a>
template&lt;typename LenT , class T , size_t N&gt; </td></tr>
<tr class="memitem:a4e99d69171c39ace6c3e79620a595158"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (T(&amp;c)[N], LenT *real_sz)</td></tr>
<tr class="separator:a4e99d69171c39ace6c3e79620a595158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970c820185fe8a0dd64c9b105f8015eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a970c820185fe8a0dd64c9b105f8015eb"></a>
template&lt;typename LenT , class T , size_t N&gt; </td></tr>
<tr class="memitem:a970c820185fe8a0dd64c9b105f8015eb"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (const T(&amp;c)[N])</td></tr>
<tr class="separator:a970c820185fe8a0dd64c9b105f8015eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e87f2b94e1520851052424752b93257"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e87f2b94e1520851052424752b93257"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a4e87f2b94e1520851052424752b93257"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (T *c, size_t sz, LenT *real_sz)</td></tr>
<tr class="separator:a4e87f2b94e1520851052424752b93257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917c42274cf0dcc84bb1bed1cdbb94f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a917c42274cf0dcc84bb1bed1cdbb94f6"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a917c42274cf0dcc84bb1bed1cdbb94f6"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (const T *c, size_t sz)</td></tr>
<tr class="separator:a917c42274cf0dcc84bb1bed1cdbb94f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6c5e8ca4296b32fdf7121669244464"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d6c5e8ca4296b32fdf7121669244464"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a6d6c5e8ca4296b32fdf7121669244464"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; LenT, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (T &amp;c, LenT max_size=0)</td></tr>
<tr class="separator:a6d6c5e8ca4296b32fdf7121669244464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0935e1208826a1912518cbeea3e13a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f0935e1208826a1912518cbeea3e13a"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a2f0935e1208826a1912518cbeea3e13a"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; LenT, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (const T &amp;c)</td></tr>
<tr class="separator:a2f0935e1208826a1912518cbeea3e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547649a191ffd803cbcb35a7939c44a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a547649a191ffd803cbcb35a7939c44a5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a547649a191ffd803cbcb35a7939c44a5"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; uint16_t, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (T &amp;c, uint16_t max_size=0)</td></tr>
<tr class="separator:a547649a191ffd803cbcb35a7939c44a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7195b9b13638bdcfbe3edb910f17066e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7195b9b13638bdcfbe3edb910f17066e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7195b9b13638bdcfbe3edb910f17066e"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; uint16_t, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (const T &amp;c)</td></tr>
<tr class="separator:a7195b9b13638bdcfbe3edb910f17066e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989fd001d06e4cbb1c87679801393ef6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a989fd001d06e4cbb1c87679801393ef6"></a>
template&lt;typename LenT , class ForwardIter &gt; </td></tr>
<tr class="memitem:a989fd001d06e4cbb1c87679801393ef6"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayRange&lt; LenT, ForwardIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::array</b> (ForwardIter first, ForwardIter last, LenT *sz=NULL)</td></tr>
<tr class="separator:a989fd001d06e4cbb1c87679801393ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Byte order</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>APIs for changing <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> / <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a> object's byte order, both permanently and temporarily.</p>
<dl class="section user"><dt>Change byte order permanently.</dt><dd>Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Net Byte Order (Big Endian).</span></div><div class="line">in &gt;&gt; Mapip::net_order;</div><div class="line">out &lt;&lt; Manip::net_order;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Host Byte Order.</span></div><div class="line">in &gt;&gt; Mapip::host_order;</div><div class="line">out &lt;&lt; Manip::host_order;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Little Endian.</span></div><div class="line">in &gt;&gt; Mapip::little_endian;</div><div class="line">out &lt;&lt; Manip::little_endian;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Big Endian (Net Byte Order).</span></div><div class="line">in &gt;&gt; Mapip::big_endian;</div><div class="line">out &lt;&lt; Manip::big_endian;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Change byte order temporarily.</dt><dd>Set byte order and pack/unpack data, then restore old byte order. <br />
 Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"><span class="keywordtype">int</span> val = 10;</div><div class="line"></div><div class="line">in &gt;&gt; Mapip::net_order_value(val);   <span class="comment">// unpack an integer using Net Byte Order, despite</span></div><div class="line">                                     <span class="comment">// the actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::net_order_value(val);  <span class="comment">// pack an integer using Net Byte Order, dspite the</span></div><div class="line">                                     <span class="comment">// actual byte order of &#39;out&#39;</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::host_order_value(val);  <span class="comment">// unpack an integer using Host Byte Order, despite</span></div><div class="line">                                     <span class="comment">// the actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::host_order_value(val); <span class="comment">// pack an integer using Host Byte Order, dspite the</span></div><div class="line">                                     <span class="comment">// actual byte order of &#39;out&#39;</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::little_endian_value(val);   <span class="comment">// unpack an integer using Little Endian, despite</span></div><div class="line">                                         <span class="comment">// the actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::little_endian_value(val);  <span class="comment">// pack an integer using Little Endian, dspite the</span></div><div class="line">                                         <span class="comment">// actual byte order of &#39;out&#39;</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::big_endian_value(val);  <span class="comment">// unpack an integer using Big Endian, despite the</span></div><div class="line">                                     <span class="comment">// actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::big_endian_value(val); <span class="comment">// pack an integer using Big Endian, dspite the actual</span></div><div class="line">                                     <span class="comment">// byte order of &#39;out&#39;</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a3c1de7bc8ce8731d798a601a9d5ee945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c1de7bc8ce8731d798a601a9d5ee945"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::net_order</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:a3c1de7bc8ce8731d798a601a9d5ee945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1699e4a8bd8f85b3da32cfce3f604f52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1699e4a8bd8f85b3da32cfce3f604f52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::host_order</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:a1699e4a8bd8f85b3da32cfce3f604f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c392998b461db2e22412654ed8c753e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c392998b461db2e22412654ed8c753e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::little_endian</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:a2c392998b461db2e22412654ed8c753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f613f2d431f89a9d7679c570fbfcbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f613f2d431f89a9d7679c570fbfcbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::big_endian</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:ac0f613f2d431f89a9d7679c570fbfcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4663bdaff02553c02817377d3771b2c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4663bdaff02553c02817377d3771b2c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4663bdaff02553c02817377d3771b2c5"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::net_order_value</b> (T &amp;val)</td></tr>
<tr class="separator:a4663bdaff02553c02817377d3771b2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff161eb3ee449c0fbfdec9fcbe48f6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ff161eb3ee449c0fbfdec9fcbe48f6a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1ff161eb3ee449c0fbfdec9fcbe48f6a"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::net_order_value</b> (const T &amp;val)</td></tr>
<tr class="separator:a1ff161eb3ee449c0fbfdec9fcbe48f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44568225662d1c1229449cdb76151b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab44568225662d1c1229449cdb76151b5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab44568225662d1c1229449cdb76151b5"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::host_order_value</b> (T &amp;val)</td></tr>
<tr class="separator:ab44568225662d1c1229449cdb76151b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03877733c8e1da3bc031b2879451c6a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03877733c8e1da3bc031b2879451c6a4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a03877733c8e1da3bc031b2879451c6a4"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::host_order_value</b> (const T &amp;val)</td></tr>
<tr class="separator:a03877733c8e1da3bc031b2879451c6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09592f8c9925084a3830ba24fb2647a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a09592f8c9925084a3830ba24fb2647a1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a09592f8c9925084a3830ba24fb2647a1"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::little_endian_value</b> (T &amp;val)</td></tr>
<tr class="separator:a09592f8c9925084a3830ba24fb2647a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34fc3a693fa6bda1f174799c99970a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac34fc3a693fa6bda1f174799c99970a6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac34fc3a693fa6bda1f174799c99970a6"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::little_endian_value</b> (const T &amp;val)</td></tr>
<tr class="separator:ac34fc3a693fa6bda1f174799c99970a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b7ae5eaf80ca2e9399929d8f5f3fde"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16b7ae5eaf80ca2e9399929d8f5f3fde"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16b7ae5eaf80ca2e9399929d8f5f3fde"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::big_endian_value</b> (T &amp;val)</td></tr>
<tr class="separator:a16b7ae5eaf80ca2e9399929d8f5f3fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ded354ba3283bb2f6017352eaa1f33f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ded354ba3283bb2f6017352eaa1f33f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ded354ba3283bb2f6017352eaa1f33f"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::big_endian_value</b> (const T &amp;val)</td></tr>
<tr class="separator:a2ded354ba3283bb2f6017352eaa1f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Current position</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>APIs for changing current position, both permanently and temporarily.</p>
<dl class="section user"><dt>Change current postion permanently</dt><dd>Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="comment">// Set current position absolutely</span></div><div class="line">in &gt;&gt; Mapip::seek(10);   <span class="comment">// Same as in.seek(10)</span></div><div class="line">out &lt;&lt; Mapip::seek(10);  <span class="comment">// Same as out.seek(10)</span></div><div class="line"></div><div class="line"><span class="comment">// Move current position relatively</span></div><div class="line">in &gt;&gt; Mapip::skip(10);   <span class="comment">// Same as in.skip(10)</span></div><div class="line">out &lt;&lt; Mapip::skip(10);  <span class="comment">// Same as out.skip(10)</span></div><div class="line">uint32_t off = -10;</div><div class="line">in &gt;&gt; Mapip::skip(&amp;off);   <span class="comment">// Same as in.skip(off)</span></div><div class="line">out &lt;&lt; Mapip::skip(&amp;off);  <span class="comment">// Same as out.skip(off)</span></div><div class="line"></div><div class="line"><span class="comment">// Fill while moving</span></div><div class="line"><span class="keywordtype">int</span> fill = <span class="charliteral">&#39;a&#39;</span>;</div><div class="line">in &gt;&gt; Mapip::skip(10, fill);   <span class="comment">// Same as in.skip(10, fill)</span></div><div class="line">out &lt;&lt; Mapip::skip(10, fill);  <span class="comment">// Same as out.skip(10, fill)</span></div><div class="line">uint32_t off = -10;</div><div class="line">in &gt;&gt; Mapip::skip(&amp;off, fill);   <span class="comment">// Same as in.skip(off, fill)</span></div><div class="line">out &lt;&lt; Mapip::skip(&amp;off, fill);  <span class="comment">// Same as out.skip(off, fill)</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Change current postion temporarily</dt><dd>Move current position and pack/unpack data, then restore old current position. <br />
 Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"><span class="keywordtype">int</span> val = 100;</div><div class="line"></div><div class="line"><span class="comment">// Unpack data from an absolute position</span></div><div class="line">in &gt;&gt; Mapip::offset_value(10, val);</div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// size_t old = in.cur();</span></div><div class="line"><span class="comment">// in.seek(10);</span></div><div class="line"><span class="comment">// in &gt;&gt; val;</span></div><div class="line"><span class="comment">// in.seek(old);</span></div><div class="line"></div><div class="line"><span class="comment">// Pack data to an absolute position</span></div><div class="line">out &lt;&lt; Mapip::offset_value(10, val);</div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// size_t old = out.cur();</span></div><div class="line"><span class="comment">// out.seek(10);</span></div><div class="line"><span class="comment">// out &lt;&lt; val;</span></div><div class="line"><span class="comment">// out.seek(old);</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Insert data (pack only)</dt><dd>Sometimes you need to <em>insert</em> a value to a particular position in already packed data, which means all existing data after that position need to move forward, to make room for the value. This operation could be complex without <code>Manip::insert</code>. <br />
 Sample code: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"><span class="keywordtype">int</span> val = 100;</div><div class="line"></div><div class="line">out &lt;&lt; Mapip::insert(10, val);   <span class="comment">// pack &#39;val&#39; at absolute position 10. Any existing data</span></div><div class="line">                                 <span class="comment">// after this position will move forward by &#39;sizeof val&#39;</span></div><div class="line">                                 <span class="comment">// bytes to make room for &#39;val&#39;</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a14ea14fc2e71a30bede372a98153c027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14ea14fc2e71a30bede372a98153c027"></a>
NS_IMPL::CManipulatorSeek&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::seek</b> (size_t pos)</td></tr>
<tr class="separator:a14ea14fc2e71a30bede372a98153c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063b64e4fb346e13ed9d1af9ea30f8c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a063b64e4fb346e13ed9d1af9ea30f8c5"></a>
NS_IMPL::CManipulatorSkip&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::skip</b> (ssize_t off)</td></tr>
<tr class="separator:a063b64e4fb346e13ed9d1af9ea30f8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671171c2631bb29028ac41d8f4cb3497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a671171c2631bb29028ac41d8f4cb3497"></a>
NS_IMPL::CManipulatorSkipFill&#160;</td><td class="memItemRight" valign="bottom"><b>Manip::skip</b> (ssize_t off, int fill)</td></tr>
<tr class="separator:a671171c2631bb29028ac41d8f4cb3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e9d14ee9a406661d613dac9aedd1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb7e9d14ee9a406661d613dac9aedd1e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb7e9d14ee9a406661d613dac9aedd1e"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorSkipPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::skip</b> (T *off)</td></tr>
<tr class="separator:aeb7e9d14ee9a406661d613dac9aedd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5ad05beafbb83df2c240c7dccbdae2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d5ad05beafbb83df2c240c7dccbdae2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d5ad05beafbb83df2c240c7dccbdae2"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorSkipPtrFill&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::skip</b> (T *off, int fill)</td></tr>
<tr class="separator:a4d5ad05beafbb83df2c240c7dccbdae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e85d76fd1c515736a254a69b1dfef68"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e85d76fd1c515736a254a69b1dfef68"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7e85d76fd1c515736a254a69b1dfef68"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorOffsetValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::offset_value</b> (size_t pos, T &amp;val)</td></tr>
<tr class="separator:a7e85d76fd1c515736a254a69b1dfef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12a05506ad9badef66ed03beede5857"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa12a05506ad9badef66ed03beede5857"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa12a05506ad9badef66ed03beede5857"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorOffsetValue&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::offset_value</b> (size_t pos, const T &amp;val)</td></tr>
<tr class="separator:aa12a05506ad9badef66ed03beede5857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9137e5a44991cc549b29c73389d1526"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9137e5a44991cc549b29c73389d1526"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac9137e5a44991cc549b29c73389d1526"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorInsert&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Manip::insert</b> (size_t pos, const T &amp;val)</td></tr>
<tr class="separator:ac9137e5a44991cc549b29c73389d1526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manip::end</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>End packing/unpacking operations.</p>
<p>When all packing/unpacking operations finish, it's a good practice to announce an <code>end</code> explicitly. <br />
 For unpacking operations (<a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>), left data size will be checked. If it's not zero, status of <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> object will be set to non-zero. Because usually some left data means you have missed something, or there is a misunderstanding about the protocol. <br />
 For packing operations (<a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>), it's always necessary to <code>end</code>. Because the underlying data buffer (whether it's internal or external) may have reserved some room for performance, so an adjustment is critical to correct its size. Besides, it will call corresponding <a class="el" href="classCOutByteStreamBasic.html#a944b54097f754a3dd27d97e2bc0c52e2">COutByteStreamBasic::finish</a> to export data. </p><dl class="section note"><dt>Note</dt><dd>Ending operation will clear all stubs, without any alignments or checks. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCOutByteStreamBasic.html#a944b54097f754a3dd27d97e2bc0c52e2" title="Export data for COutByteStreamStrRef, COutByteStreamVecRef. ">COutByteStreamBasic::finish</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a73ecc2775c7844cb4ca9566cd115043d"><td class="memItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a> ()</td></tr>
<tr class="memdesc:a73ecc2775c7844cb4ca9566cd115043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="classCInByteStream.html">CInByteStream</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>.  <a href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">More...</a><br /></td></tr>
<tr class="separator:a73ecc2775c7844cb4ca9566cd115043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791fd267a1c67d68c52fab09cf53fb4b"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:a791fd267a1c67d68c52fab09cf53fb4b"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; SizeT *, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a791fd267a1c67d68c52fab09cf53fb4b">Manip::end</a> (SizeT *sz)</td></tr>
<tr class="memdesc:a791fd267a1c67d68c52fab09cf53fb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>.  <a href="namespaceManip.html#a791fd267a1c67d68c52fab09cf53fb4b">More...</a><br /></td></tr>
<tr class="separator:a791fd267a1c67d68c52fab09cf53fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8e99fa7b7888b311ff70615972f651"><td class="memTemplParams" colspan="2">template&lt;class BufT &gt; </td></tr>
<tr class="memitem:a6c8e99fa7b7888b311ff70615972f651"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; BufT, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a6c8e99fa7b7888b311ff70615972f651">Manip::end</a> (BufT &amp;buf)</td></tr>
<tr class="memdesc:a6c8e99fa7b7888b311ff70615972f651"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>.  <a href="namespaceManip.html#a6c8e99fa7b7888b311ff70615972f651">More...</a><br /></td></tr>
<tr class="separator:a6c8e99fa7b7888b311ff70615972f651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539de852da4658c596026d1aa9d5669c"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; </td></tr>
<tr class="memitem:a539de852da4658c596026d1aa9d5669c"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; CharT *, size_t * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a539de852da4658c596026d1aa9d5669c">Manip::end</a> (CharT *buf, size_t *sz)</td></tr>
<tr class="memdesc:a539de852da4658c596026d1aa9d5669c"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>, <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a>.  <a href="namespaceManip.html#a539de852da4658c596026d1aa9d5669c">More...</a><br /></td></tr>
<tr class="separator:a539de852da4658c596026d1aa9d5669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data packing library using stream style interfaces. </p>
<dl class="section author"><dt>Author</dt><dd>Zhao DAI </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="afb6d169189f59f48cb8b8c19cea19b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt;NS_IMPL::__buf_data&lt;<a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt;char&gt; &gt; &gt; <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use external <code>char</code> array as the underlying data buffer. </p>

</div>
</div>
<a class="anchor" id="a0ef01e09d25bd19584df091684fd736c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt;NS_IMPL::__buf_data&lt;std::string&gt; &gt; <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use internal <code>std::string</code> as the underlying data buffer. </p>

</div>
</div>
<a class="anchor" id="a8437a5fc88be591f9b1525fff60ccc82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt;NS_IMPL::__buf_ref_data&lt;std::string&gt; &gt; <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use external <code>std::string</code> as the underlying data buffer. </p>

</div>
</div>
<a class="anchor" id="ad8bd78a8893b4db9e628d4c8f1996057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt;NS_IMPL::__buf_data&lt;std::vector&lt;char&gt; &gt; &gt; <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use internal <code>std::vector&lt;char&gt;</code> as the underlying data buffer. </p>

</div>
</div>
<a class="anchor" id="af39d48292420eb915840ecb1b005fece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classCOutByteStreamBasic.html">COutByteStreamBasic</a>&lt;NS_IMPL::__buf_ref_data&lt;std::vector&lt;char&gt; &gt; &gt; <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use external <code>std::vector&lt;char&gt;</code> as the underlying data buffer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
