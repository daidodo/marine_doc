<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Marine Library: CCharBuffer&lt; CharT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marine Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for Linux Networking Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCCharBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CCharBuffer&lt; CharT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provide interfaces similar to <code>std::string</code> for raw byte array.  
 <a href="classCCharBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="char__buffer_8hh_source.html">char_buffer.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1303c3bbc4e0440bc53875d1c5a64ee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1303c3bbc4e0440bc53875d1c5a64ee7"></a>
typedef std::char_traits&lt; __Char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b></td></tr>
<tr class="separator:a1303c3bbc4e0440bc53875d1c5a64ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ed90c89f8f51bc6169fa33032d59a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29ed90c89f8f51bc6169fa33032d59a7"></a>
typedef traits_type::char_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a29ed90c89f8f51bc6169fa33032d59a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac518039484d1b6b3743fcf3cbe5bf2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abac518039484d1b6b3743fcf3cbe5bf2"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:abac518039484d1b6b3743fcf3cbe5bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f5b265a91235ddc31b9cc5ff5c7484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7f5b265a91235ddc31b9cc5ff5c7484"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:aa7f5b265a91235ddc31b9cc5ff5c7484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712106af17fd7052239885fda72d5021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a712106af17fd7052239885fda72d5021"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a712106af17fd7052239885fda72d5021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88b13079d171a37ead6847c392cf8ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88b13079d171a37ead6847c392cf8ee"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:ac88b13079d171a37ead6847c392cf8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e9c9bfb24915185add1ccadeff001f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e9c9bfb24915185add1ccadeff001f"></a>
typedef __gnu_cxx::__normal_iterator&lt; pointer, <a class="el" href="classCCharBuffer.html">CCharBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a32e9c9bfb24915185add1ccadeff001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95689b91ac5eabae0a5f6e2597fa56e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae95689b91ac5eabae0a5f6e2597fa56e"></a>
typedef __gnu_cxx::__normal_iterator&lt; const_pointer, <a class="el" href="classCCharBuffer.html">CCharBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ae95689b91ac5eabae0a5f6e2597fa56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b57bf2a413e8480c180da4a966ff05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66b57bf2a413e8480c180da4a966ff05"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a66b57bf2a413e8480c180da4a966ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4f22f2cad2b7c908ba41a7e139ebc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4f22f2cad2b7c908ba41a7e139ebc9"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a2e4f22f2cad2b7c908ba41a7e139ebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b5e0b575cb7657c2a75d6386af6498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b5e0b575cb7657c2a75d6386af6498"></a>
typedef std::reverse_iterator&lt; iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a25b5e0b575cb7657c2a75d6386af6498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30ca01b5c7fb81c74e93ca8a01e9c54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac30ca01b5c7fb81c74e93ca8a01e9c54"></a>
typedef std::reverse_iterator&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:ac30ca01b5c7fb81c74e93ca8a01e9c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab906b756ab899cfab97b7733a4b63427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab906b756ab899cfab97b7733a4b63427"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ab906b756ab899cfab97b7733a4b63427">CCharBuffer</a> ()</td></tr>
<tr class="memdesc:ab906b756ab899cfab97b7733a4b63427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <em>null</em> object with zero capacity. <br /></td></tr>
<tr class="separator:ab906b756ab899cfab97b7733a4b63427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad535b8ba596b55eb66b22d4b7774e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ab1ad535b8ba596b55eb66b22d4b7774e">CCharBuffer</a> (pointer buf)</td></tr>
<tr class="memdesc:ab1ad535b8ba596b55eb66b22d4b7774e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a C-style string.  <a href="#ab1ad535b8ba596b55eb66b22d4b7774e">More...</a><br /></td></tr>
<tr class="separator:ab1ad535b8ba596b55eb66b22d4b7774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3023e8041e9a19cff5414e9747dfade4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a3023e8041e9a19cff5414e9747dfade4">CCharBuffer</a> (pointer buf, size_type <a class="el" href="classCCharBuffer.html#ad1d6be15af1bdbf1497afc3823e4eac6">capacity</a>, size_type <a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47">size</a>=0)</td></tr>
<tr class="memdesc:a3023e8041e9a19cff5414e9747dfade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a byte buffer.  <a href="#a3023e8041e9a19cff5414e9747dfade4">More...</a><br /></td></tr>
<tr class="separator:a3023e8041e9a19cff5414e9747dfade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36f7b090637b8ef13bb73c98fa1648f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ac36f7b090637b8ef13bb73c98fa1648f">assign</a> (pointer buf, size_type <a class="el" href="classCCharBuffer.html#ad1d6be15af1bdbf1497afc3823e4eac6">capacity</a>, size_type <a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47">size</a>=0)</td></tr>
<tr class="memdesc:ac36f7b090637b8ef13bb73c98fa1648f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this object to manage a byte buffer.  <a href="#ac36f7b090637b8ef13bb73c98fa1648f">More...</a><br /></td></tr>
<tr class="separator:ac36f7b090637b8ef13bb73c98fa1648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f96a2ee0139645f35677e3a7bdac40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a2f96a2ee0139645f35677e3a7bdac40a">assign</a> (const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)</td></tr>
<tr class="memdesc:a2f96a2ee0139645f35677e3a7bdac40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this object to manage a buffer from another object.  <a href="#a2f96a2ee0139645f35677e3a7bdac40a">More...</a><br /></td></tr>
<tr class="separator:a2f96a2ee0139645f35677e3a7bdac40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae382ca22e252780a7689470e90d8f36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ae382ca22e252780a7689470e90d8f36c">swap</a> (<a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)  throw ()</td></tr>
<tr class="memdesc:ae382ca22e252780a7689470e90d8f36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> objects.  <a href="#ae382ca22e252780a7689470e90d8f36c">More...</a><br /></td></tr>
<tr class="separator:ae382ca22e252780a7689470e90d8f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a0a33b71fcdbac5bb363ed576a9101d18"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18">begin</a> ()</td></tr>
<tr class="memdesc:a0a33b71fcdbac5bb363ed576a9101d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the beginning of the data.  <a href="#a0a33b71fcdbac5bb363ed576a9101d18">More...</a><br /></td></tr>
<tr class="separator:a0a33b71fcdbac5bb363ed576a9101d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73fdbacae3841153c1a5091e86b04da"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#aa73fdbacae3841153c1a5091e86b04da">end</a> ()</td></tr>
<tr class="memdesc:aa73fdbacae3841153c1a5091e86b04da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ending of the data.  <a href="#aa73fdbacae3841153c1a5091e86b04da">More...</a><br /></td></tr>
<tr class="separator:aa73fdbacae3841153c1a5091e86b04da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca8affe0a06e5b0356a74dc69705b98"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a4ca8affe0a06e5b0356a74dc69705b98">begin</a> () const </td></tr>
<tr class="memdesc:a4ca8affe0a06e5b0356a74dc69705b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the beginning of the data.  <a href="#a4ca8affe0a06e5b0356a74dc69705b98">More...</a><br /></td></tr>
<tr class="separator:a4ca8affe0a06e5b0356a74dc69705b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa420722bc2a70d025cde9c649fb53949"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#aa420722bc2a70d025cde9c649fb53949">end</a> () const </td></tr>
<tr class="memdesc:aa420722bc2a70d025cde9c649fb53949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ending of the data.  <a href="#aa420722bc2a70d025cde9c649fb53949">More...</a><br /></td></tr>
<tr class="separator:aa420722bc2a70d025cde9c649fb53949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f2e51a4f4a0e4ef40464d6982bab8"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ae75f2e51a4f4a0e4ef40464d6982bab8">rbegin</a> ()</td></tr>
<tr class="memdesc:ae75f2e51a4f4a0e4ef40464d6982bab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ending of the data.  <a href="#ae75f2e51a4f4a0e4ef40464d6982bab8">More...</a><br /></td></tr>
<tr class="separator:ae75f2e51a4f4a0e4ef40464d6982bab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633b18697ad02fd1e105a0b25116e44a"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a633b18697ad02fd1e105a0b25116e44a">rend</a> ()</td></tr>
<tr class="memdesc:a633b18697ad02fd1e105a0b25116e44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the beginning of the data.  <a href="#a633b18697ad02fd1e105a0b25116e44a">More...</a><br /></td></tr>
<tr class="separator:a633b18697ad02fd1e105a0b25116e44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3831bc64d914c1ce9c8ab959b83ce505"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a3831bc64d914c1ce9c8ab959b83ce505">rbegin</a> () const </td></tr>
<tr class="memdesc:a3831bc64d914c1ce9c8ab959b83ce505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ending of the data.  <a href="#a3831bc64d914c1ce9c8ab959b83ce505">More...</a><br /></td></tr>
<tr class="separator:a3831bc64d914c1ce9c8ab959b83ce505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a26d10a386f0ed6e51dbea5a80701fe"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a5a26d10a386f0ed6e51dbea5a80701fe">rend</a> () const </td></tr>
<tr class="memdesc:a5a26d10a386f0ed6e51dbea5a80701fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the beginning of the data.  <a href="#a5a26d10a386f0ed6e51dbea5a80701fe">More...</a><br /></td></tr>
<tr class="separator:a5a26d10a386f0ed6e51dbea5a80701fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:ab4c37f18778dbea654664d3e6e5c85e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ab4c37f18778dbea654664d3e6e5c85e7">empty</a> () const </td></tr>
<tr class="memdesc:ab4c37f18778dbea654664d3e6e5c85e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the data is empty.  <a href="#ab4c37f18778dbea654664d3e6e5c85e7">More...</a><br /></td></tr>
<tr class="separator:ab4c37f18778dbea654664d3e6e5c85e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6232248ce2a504d68bd4726b0c6ad32f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a6232248ce2a504d68bd4726b0c6ad32f">length</a> () const </td></tr>
<tr class="memdesc:a6232248ce2a504d68bd4726b0c6ad32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the data, same as <code><a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47" title="Get the size of the data. ">size()</a></code>.  <a href="#a6232248ce2a504d68bd4726b0c6ad32f">More...</a><br /></td></tr>
<tr class="separator:a6232248ce2a504d68bd4726b0c6ad32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e396e7316d367069e7a1a5c761ba47"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47">size</a> () const </td></tr>
<tr class="memdesc:a15e396e7316d367069e7a1a5c761ba47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the data.  <a href="#a15e396e7316d367069e7a1a5c761ba47">More...</a><br /></td></tr>
<tr class="separator:a15e396e7316d367069e7a1a5c761ba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6be15af1bdbf1497afc3823e4eac6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ad1d6be15af1bdbf1497afc3823e4eac6">capacity</a> () const </td></tr>
<tr class="memdesc:ad1d6be15af1bdbf1497afc3823e4eac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the underlying byte buffer.  <a href="#ad1d6be15af1bdbf1497afc3823e4eac6">More...</a><br /></td></tr>
<tr class="separator:ad1d6be15af1bdbf1497afc3823e4eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da9367e03ee90bb7c350e7e19791837"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a9da9367e03ee90bb7c350e7e19791837">max_size</a> () const </td></tr>
<tr class="memdesc:a9da9367e03ee90bb7c350e7e19791837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of bytes.  <a href="#a9da9367e03ee90bb7c350e7e19791837">More...</a><br /></td></tr>
<tr class="separator:a9da9367e03ee90bb7c350e7e19791837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr class="memitem:aedbe2747e0353dbe00fe3c016d07e144"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#aedbe2747e0353dbe00fe3c016d07e144">operator[]</a> (size_type i)</td></tr>
<tr class="memdesc:aedbe2747e0353dbe00fe3c016d07e144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a byte.  <a href="#aedbe2747e0353dbe00fe3c016d07e144">More...</a><br /></td></tr>
<tr class="separator:aedbe2747e0353dbe00fe3c016d07e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32194cedee509bfd5bd6013bbe313493"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a32194cedee509bfd5bd6013bbe313493">operator[]</a> (size_type i) const </td></tr>
<tr class="memdesc:a32194cedee509bfd5bd6013bbe313493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a byte.  <a href="#a32194cedee509bfd5bd6013bbe313493">More...</a><br /></td></tr>
<tr class="separator:a32194cedee509bfd5bd6013bbe313493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c62f4e79202006cd3d10553707d31"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#aa99c62f4e79202006cd3d10553707d31">front</a> ()</td></tr>
<tr class="memdesc:aa99c62f4e79202006cd3d10553707d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first byte.  <a href="#aa99c62f4e79202006cd3d10553707d31">More...</a><br /></td></tr>
<tr class="separator:aa99c62f4e79202006cd3d10553707d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2317d30430067662ba201dcfc1950cb3"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a2317d30430067662ba201dcfc1950cb3">front</a> () const </td></tr>
<tr class="memdesc:a2317d30430067662ba201dcfc1950cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first byte.  <a href="#a2317d30430067662ba201dcfc1950cb3">More...</a><br /></td></tr>
<tr class="separator:a2317d30430067662ba201dcfc1950cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436dab00f0858a7c1dd2fc9a54323316"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a436dab00f0858a7c1dd2fc9a54323316">back</a> ()</td></tr>
<tr class="memdesc:a436dab00f0858a7c1dd2fc9a54323316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last byte.  <a href="#a436dab00f0858a7c1dd2fc9a54323316">More...</a><br /></td></tr>
<tr class="separator:a436dab00f0858a7c1dd2fc9a54323316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9b703403b69fb2484de83f4d42b5f6"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a4f9b703403b69fb2484de83f4d42b5f6">back</a> () const </td></tr>
<tr class="memdesc:a4f9b703403b69fb2484de83f4d42b5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last byte.  <a href="#a4f9b703403b69fb2484de83f4d42b5f6">More...</a><br /></td></tr>
<tr class="separator:a4f9b703403b69fb2484de83f4d42b5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c734d4c31f8f6daee91a312f10177eb"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a4c734d4c31f8f6daee91a312f10177eb">at</a> (size_type i)</td></tr>
<tr class="memdesc:a4c734d4c31f8f6daee91a312f10177eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a certain byte.  <a href="#a4c734d4c31f8f6daee91a312f10177eb">More...</a><br /></td></tr>
<tr class="separator:a4c734d4c31f8f6daee91a312f10177eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85b488caebcb1249575bdb5d7d783c"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a0d85b488caebcb1249575bdb5d7d783c">at</a> (size_type i) const </td></tr>
<tr class="memdesc:a0d85b488caebcb1249575bdb5d7d783c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a certain byte.  <a href="#a0d85b488caebcb1249575bdb5d7d783c">More...</a><br /></td></tr>
<tr class="separator:a0d85b488caebcb1249575bdb5d7d783c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1197c2e4bec02fb3e24994596846c60f"><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a1197c2e4bec02fb3e24994596846c60f">c_str</a> () const </td></tr>
<tr class="memdesc:a1197c2e4bec02fb3e24994596846c60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying C-style string.  <a href="#a1197c2e4bec02fb3e24994596846c60f">More...</a><br /></td></tr>
<tr class="separator:a1197c2e4bec02fb3e24994596846c60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebc5fd002e96535aad2ca22e50a295d"><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a6ebc5fd002e96535aad2ca22e50a295d">data</a> () const </td></tr>
<tr class="memdesc:a6ebc5fd002e96535aad2ca22e50a295d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data pointer.  <a href="#a6ebc5fd002e96535aad2ca22e50a295d">More...</a><br /></td></tr>
<tr class="separator:a6ebc5fd002e96535aad2ca22e50a295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If any of the following operations makes <code>size</code> exceed <code>capacity</code>, an <em>exception</em> will be thrown to indicate the error. </p>
</div></td></tr>
<tr class="memitem:a196c7982d8f0b27435856444d13ad96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a196c7982d8f0b27435856444d13ad96f">clear</a> ()</td></tr>
<tr class="memdesc:a196c7982d8f0b27435856444d13ad96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the data.  <a href="#a196c7982d8f0b27435856444d13ad96f">More...</a><br /></td></tr>
<tr class="separator:a196c7982d8f0b27435856444d13ad96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37819fe64b068ba3ef9f9beb9645ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ab37819fe64b068ba3ef9f9beb9645ae3">resize</a> (size_type count, value_type val=0)</td></tr>
<tr class="memdesc:ab37819fe64b068ba3ef9f9beb9645ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the data.  <a href="#ab37819fe64b068ba3ef9f9beb9645ae3">More...</a><br /></td></tr>
<tr class="separator:ab37819fe64b068ba3ef9f9beb9645ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb90d96d78619f5c75041bdbe5dddbac"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#afb90d96d78619f5c75041bdbe5dddbac">copy</a> (pointer buf, size_type count, size_type offset=0) const </td></tr>
<tr class="memdesc:afb90d96d78619f5c75041bdbe5dddbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy content of a buffer to self.  <a href="#afb90d96d78619f5c75041bdbe5dddbac">More...</a><br /></td></tr>
<tr class="separator:afb90d96d78619f5c75041bdbe5dddbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475218796dde0a3efbbbbdce7a5f6916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a475218796dde0a3efbbbbdce7a5f6916">push_back</a> (value_type val)</td></tr>
<tr class="memdesc:a475218796dde0a3efbbbbdce7a5f6916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a byte to the end of the data.  <a href="#a475218796dde0a3efbbbbdce7a5f6916">More...</a><br /></td></tr>
<tr class="separator:a475218796dde0a3efbbbbdce7a5f6916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902b809b23505046622d63cb4a0ad1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ad902b809b23505046622d63cb4a0ad1f">append</a> (size_type count, value_type val)</td></tr>
<tr class="memdesc:ad902b809b23505046622d63cb4a0ad1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a number of bytes to the end of the data.  <a href="#ad902b809b23505046622d63cb4a0ad1f">More...</a><br /></td></tr>
<tr class="separator:ad902b809b23505046622d63cb4a0ad1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582a971525cd30c573fb0b500ca3f893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a582a971525cd30c573fb0b500ca3f893">append</a> (const_pointer buf, size_type count)</td></tr>
<tr class="memdesc:a582a971525cd30c573fb0b500ca3f893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append content of a buffer to the end of the data.  <a href="#a582a971525cd30c573fb0b500ca3f893">More...</a><br /></td></tr>
<tr class="separator:a582a971525cd30c573fb0b500ca3f893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe2c388fe0bcd0481c4f3995378e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ae9fe2c388fe0bcd0481c4f3995378e92">append</a> (const_pointer buf)</td></tr>
<tr class="memdesc:ae9fe2c388fe0bcd0481c4f3995378e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a C-style string to the end of the data.  <a href="#ae9fe2c388fe0bcd0481c4f3995378e92">More...</a><br /></td></tr>
<tr class="separator:ae9fe2c388fe0bcd0481c4f3995378e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fce2de666975efdf5a43c3f83588dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a42fce2de666975efdf5a43c3f83588dd">append</a> (const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other, size_type offset, size_type count)</td></tr>
<tr class="memdesc:a42fce2de666975efdf5a43c3f83588dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> content to the end of the data.  <a href="#a42fce2de666975efdf5a43c3f83588dd">More...</a><br /></td></tr>
<tr class="separator:a42fce2de666975efdf5a43c3f83588dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59649d58496900eec19401d4bbf66379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a59649d58496900eec19401d4bbf66379">append</a> (const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)</td></tr>
<tr class="memdesc:a59649d58496900eec19401d4bbf66379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> content to the end of the data.  <a href="#a59649d58496900eec19401d4bbf66379">More...</a><br /></td></tr>
<tr class="separator:a59649d58496900eec19401d4bbf66379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e312d58883cf6bbea06eec2057117c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a46e312d58883cf6bbea06eec2057117c">operator+=</a> (const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)</td></tr>
<tr class="memdesc:a46e312d58883cf6bbea06eec2057117c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> to the end of the data.  <a href="#a46e312d58883cf6bbea06eec2057117c">More...</a><br /></td></tr>
<tr class="separator:a46e312d58883cf6bbea06eec2057117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeee7b17a26c2f8e666c0e044652d8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#abeee7b17a26c2f8e666c0e044652d8ea">operator+=</a> (const_pointer buf)</td></tr>
<tr class="memdesc:abeee7b17a26c2f8e666c0e044652d8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a C-style string to the end of the data.  <a href="#abeee7b17a26c2f8e666c0e044652d8ea">More...</a><br /></td></tr>
<tr class="separator:abeee7b17a26c2f8e666c0e044652d8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c31bb24cfe95e4646ec0877eceef63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a7c31bb24cfe95e4646ec0877eceef63f">operator+=</a> (value_type val)</td></tr>
<tr class="memdesc:a7c31bb24cfe95e4646ec0877eceef63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a byte to the end of the data.  <a href="#a7c31bb24cfe95e4646ec0877eceef63f">More...</a><br /></td></tr>
<tr class="separator:a7c31bb24cfe95e4646ec0877eceef63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30077e16cd16842d165070ff5de9f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ac30077e16cd16842d165070ff5de9f5f">insert</a> (size_type offset, size_type count, value_type val)</td></tr>
<tr class="memdesc:ac30077e16cd16842d165070ff5de9f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a number of bytes.  <a href="#ac30077e16cd16842d165070ff5de9f5f">More...</a><br /></td></tr>
<tr class="separator:ac30077e16cd16842d165070ff5de9f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f360b51c215b966e5dfd9920a24b1b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a7f360b51c215b966e5dfd9920a24b1b4">insert</a> (size_type offset, const_pointer buf, size_type count)</td></tr>
<tr class="memdesc:a7f360b51c215b966e5dfd9920a24b1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the content of a buffer.  <a href="#a7f360b51c215b966e5dfd9920a24b1b4">More...</a><br /></td></tr>
<tr class="separator:a7f360b51c215b966e5dfd9920a24b1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117de1aab09c34a36f535a62b80148c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a117de1aab09c34a36f535a62b80148c2">insert</a> (size_type offset, const_pointer buf)</td></tr>
<tr class="memdesc:a117de1aab09c34a36f535a62b80148c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a C-style string.  <a href="#a117de1aab09c34a36f535a62b80148c2">More...</a><br /></td></tr>
<tr class="separator:a117de1aab09c34a36f535a62b80148c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406054d49cb3b2de087da1b75b8a374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a1406054d49cb3b2de087da1b75b8a374">insert</a> (size_type offset, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other, size_type newOffset, size_type count)</td></tr>
<tr class="memdesc:a1406054d49cb3b2de087da1b75b8a374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>.  <a href="#a1406054d49cb3b2de087da1b75b8a374">More...</a><br /></td></tr>
<tr class="separator:a1406054d49cb3b2de087da1b75b8a374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3316d59122b319140bc2994ba699df2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a3316d59122b319140bc2994ba699df2b">insert</a> (size_type offset, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)</td></tr>
<tr class="memdesc:a3316d59122b319140bc2994ba699df2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>.  <a href="#a3316d59122b319140bc2994ba699df2b">More...</a><br /></td></tr>
<tr class="separator:a3316d59122b319140bc2994ba699df2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a257d1cd75a830c530b5e31e0d0f087"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a0a257d1cd75a830c530b5e31e0d0f087">insert</a> (iterator pos, value_type val)</td></tr>
<tr class="memdesc:a0a257d1cd75a830c530b5e31e0d0f087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a byte.  <a href="#a0a257d1cd75a830c530b5e31e0d0f087">More...</a><br /></td></tr>
<tr class="separator:a0a257d1cd75a830c530b5e31e0d0f087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afdc05cfe65cd533aaf7f415b51f85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a6afdc05cfe65cd533aaf7f415b51f85b">replace</a> (size_type offset, size_type count, size_type newCount, value_type val)</td></tr>
<tr class="memdesc:a6afdc05cfe65cd533aaf7f415b51f85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with a number of new bytes.  <a href="#a6afdc05cfe65cd533aaf7f415b51f85b">More...</a><br /></td></tr>
<tr class="separator:a6afdc05cfe65cd533aaf7f415b51f85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6aa614be0b19de1c3504bf7ce510ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a2e6aa614be0b19de1c3504bf7ce510ea">replace</a> (size_type offset, size_type count, const_pointer buf, size_type newCount)</td></tr>
<tr class="memdesc:a2e6aa614be0b19de1c3504bf7ce510ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of a byte buffer.  <a href="#a2e6aa614be0b19de1c3504bf7ce510ea">More...</a><br /></td></tr>
<tr class="separator:a2e6aa614be0b19de1c3504bf7ce510ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a82d12b950a1b90c7ebdf7b9d4c97d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a6a82d12b950a1b90c7ebdf7b9d4c97d6">replace</a> (size_type offset, size_type count, const_pointer buf)</td></tr>
<tr class="memdesc:a6a82d12b950a1b90c7ebdf7b9d4c97d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of a C-style string.  <a href="#a6a82d12b950a1b90c7ebdf7b9d4c97d6">More...</a><br /></td></tr>
<tr class="separator:a6a82d12b950a1b90c7ebdf7b9d4c97d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62917f71afa12f21713105b2645c9068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a62917f71afa12f21713105b2645c9068">replace</a> (size_type offset, size_type count, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other, size_type newOffset, size_type newCount)</td></tr>
<tr class="memdesc:a62917f71afa12f21713105b2645c9068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>.  <a href="#a62917f71afa12f21713105b2645c9068">More...</a><br /></td></tr>
<tr class="separator:a62917f71afa12f21713105b2645c9068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c682c1eb36aa84e279b68ef5ec9202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a19c682c1eb36aa84e279b68ef5ec9202">replace</a> (size_type offset, size_type count, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)</td></tr>
<tr class="memdesc:a19c682c1eb36aa84e279b68ef5ec9202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>.  <a href="#a19c682c1eb36aa84e279b68ef5ec9202">More...</a><br /></td></tr>
<tr class="separator:a19c682c1eb36aa84e279b68ef5ec9202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab315f3454acae8bdc099eeafcc7af95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ab315f3454acae8bdc099eeafcc7af95d">replace</a> (iterator first, iterator last, size_type count, value_type val)</td></tr>
<tr class="memdesc:ab315f3454acae8bdc099eeafcc7af95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with a number of new bytes.  <a href="#ab315f3454acae8bdc099eeafcc7af95d">More...</a><br /></td></tr>
<tr class="separator:ab315f3454acae8bdc099eeafcc7af95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755e4c5d2b34806f8abed0ecf1742107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a755e4c5d2b34806f8abed0ecf1742107">replace</a> (iterator first, iterator last, const_pointer buf, size_type count)</td></tr>
<tr class="memdesc:a755e4c5d2b34806f8abed0ecf1742107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of a byte buffer.  <a href="#a755e4c5d2b34806f8abed0ecf1742107">More...</a><br /></td></tr>
<tr class="separator:a755e4c5d2b34806f8abed0ecf1742107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ec53885360699fe8de2ebc2a21b633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a08ec53885360699fe8de2ebc2a21b633">replace</a> (iterator first, iterator last, const_pointer buf)</td></tr>
<tr class="memdesc:a08ec53885360699fe8de2ebc2a21b633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of a C-style string.  <a href="#a08ec53885360699fe8de2ebc2a21b633">More...</a><br /></td></tr>
<tr class="separator:a08ec53885360699fe8de2ebc2a21b633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42219269dcda027fe9b7be963d3d3ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a42219269dcda027fe9b7be963d3d3ca6">replace</a> (iterator first, iterator last, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other, size_type offset, size_type count)</td></tr>
<tr class="memdesc:a42219269dcda027fe9b7be963d3d3ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>.  <a href="#a42219269dcda027fe9b7be963d3d3ca6">More...</a><br /></td></tr>
<tr class="separator:a42219269dcda027fe9b7be963d3d3ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733cdaa5755bf99b41b37bc973dca133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a733cdaa5755bf99b41b37bc973dca133">replace</a> (iterator first, iterator last, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other)</td></tr>
<tr class="memdesc:a733cdaa5755bf99b41b37bc973dca133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>.  <a href="#a733cdaa5755bf99b41b37bc973dca133">More...</a><br /></td></tr>
<tr class="separator:a733cdaa5755bf99b41b37bc973dca133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4831d98d432cc17836d4ebf7580df209"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a4831d98d432cc17836d4ebf7580df209">erase</a> (iterator first, iterator last)</td></tr>
<tr class="memdesc:a4831d98d432cc17836d4ebf7580df209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of bytes.  <a href="#a4831d98d432cc17836d4ebf7580df209">More...</a><br /></td></tr>
<tr class="separator:a4831d98d432cc17836d4ebf7580df209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a2ba1ede5bee5f563efdf196ad91f8"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a90a2ba1ede5bee5f563efdf196ad91f8">erase</a> (iterator pos)</td></tr>
<tr class="memdesc:a90a2ba1ede5bee5f563efdf196ad91f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a byte.  <a href="#a90a2ba1ede5bee5f563efdf196ad91f8">More...</a><br /></td></tr>
<tr class="separator:a90a2ba1ede5bee5f563efdf196ad91f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1de00f56d49ee81338a2a554006c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a7d1de00f56d49ee81338a2a554006c1e">erase</a> (size_type offset=0, size_type count=npos)</td></tr>
<tr class="memdesc:a7d1de00f56d49ee81338a2a554006c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of bytes.  <a href="#a7d1de00f56d49ee81338a2a554006c1e">More...</a><br /></td></tr>
<tr class="separator:a7d1de00f56d49ee81338a2a554006c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85654201646d22b7a162a4fa69bdeed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCCharBuffer.html">__Myt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a85654201646d22b7a162a4fa69bdeed3">substr</a> (size_type offset=0, size_type count=npos)</td></tr>
<tr class="memdesc:a85654201646d22b7a162a4fa69bdeed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a substring.  <a href="#a85654201646d22b7a162a4fa69bdeed3">More...</a><br /></td></tr>
<tr class="separator:a85654201646d22b7a162a4fa69bdeed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c0bf8234ec5194abf3f3a3dbd2e573"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ab8c0bf8234ec5194abf3f3a3dbd2e573">compare</a> (size_type offset, size_type count, const_pointer buf, size_type newCount) const </td></tr>
<tr class="memdesc:ab8c0bf8234ec5194abf3f3a3dbd2e573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a range of bytes with a buffer lexicographically.  <a href="#ab8c0bf8234ec5194abf3f3a3dbd2e573">More...</a><br /></td></tr>
<tr class="separator:ab8c0bf8234ec5194abf3f3a3dbd2e573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bb071ebca96f446bf9ad462d7f61af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a80bb071ebca96f446bf9ad462d7f61af">compare</a> (size_type offset, size_type count, const_pointer buf) const </td></tr>
<tr class="memdesc:a80bb071ebca96f446bf9ad462d7f61af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a range of bytes with a C-style string lexicographically.  <a href="#a80bb071ebca96f446bf9ad462d7f61af">More...</a><br /></td></tr>
<tr class="separator:a80bb071ebca96f446bf9ad462d7f61af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e3805bfd15d4b0de2c8d93d0b0eda8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#ae9e3805bfd15d4b0de2c8d93d0b0eda8">compare</a> (const_pointer buf) const </td></tr>
<tr class="memdesc:ae9e3805bfd15d4b0de2c8d93d0b0eda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare self with a C-style string lexicographically.  <a href="#ae9e3805bfd15d4b0de2c8d93d0b0eda8">More...</a><br /></td></tr>
<tr class="separator:ae9e3805bfd15d4b0de2c8d93d0b0eda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319aefb3eec8692f0cbc21d84cbbc6b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a319aefb3eec8692f0cbc21d84cbbc6b2">compare</a> (size_type offset, size_type count, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other, size_type newOffset, size_type newCount) const </td></tr>
<tr class="memdesc:a319aefb3eec8692f0cbc21d84cbbc6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a range of bytes with another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object.  <a href="#a319aefb3eec8692f0cbc21d84cbbc6b2">More...</a><br /></td></tr>
<tr class="separator:a319aefb3eec8692f0cbc21d84cbbc6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718f03f339d4342762e408b83e3e05d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#a718f03f339d4342762e408b83e3e05d7">compare</a> (size_type offset, size_type count, const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other) const </td></tr>
<tr class="memdesc:a718f03f339d4342762e408b83e3e05d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a range of bytes with another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object.  <a href="#a718f03f339d4342762e408b83e3e05d7">More...</a><br /></td></tr>
<tr class="separator:a718f03f339d4342762e408b83e3e05d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7c5cdc8bef8996ab0e88f93446bfe7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCCharBuffer.html#aae7c5cdc8bef8996ab0e88f93446bfe7">compare</a> (const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;other) const </td></tr>
<tr class="memdesc:aae7c5cdc8bef8996ab0e88f93446bfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare self with another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object.  <a href="#aae7c5cdc8bef8996ab0e88f93446bfe7">More...</a><br /></td></tr>
<tr class="separator:aae7c5cdc8bef8996ab0e88f93446bfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac7e1944277402b1dcccf1a5edae7d729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e1944277402b1dcccf1a5edae7d729"></a>
static const size_type&#160;</td><td class="memItemRight" valign="bottom"><b>npos</b> = static_cast&lt;size_type&gt;(-1)</td></tr>
<tr class="separator:ac7e1944277402b1dcccf1a5edae7d729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CharT&gt;<br />
class CCharBuffer&lt; CharT &gt;</h3>

<p>Provide interfaces similar to <code>std::string</code> for raw byte array. </p>
<p><a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> provides convenient interfaces, like <code>begin/end</code>, <code>append</code>, <code>insert</code>, to manipulate a byte array, and performs necessary boundary checks to prevent access violation. It does <em>NOT</em> manage memory, so the user is responsible for the validation of the underlying buffer. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>A character type, must be <code>char</code>, <code>unsigned char</code> or <code>signed char</code>. Other wider sized types are <em>NOT</em> supported, e.g. <code>wchar_t</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab1ad535b8ba596b55eb66b22d4b7774e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::<a class="el" href="classCCharBuffer.html">CCharBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">pointer&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a C-style string. </p>
<p>Both size and capacity are set to <code>strlen(buf)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3023e8041e9a19cff5414e9747dfade4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::<a class="el" href="classCCharBuffer.html">CCharBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>Size of bytes that this object can manipulate. It could be smaller than the allocated size of <code>buf</code>, but not greater. </td></tr>
    <tr><td class="paramname">size</td><td>Size of used bytes. It should be no more that <code>capacity</code>, otherwise <code>capacity</code> will be used instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad902b809b23505046622d63cb4a0ad1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::append </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a number of bytes to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of bytes to append. </td></tr>
    <tr><td class="paramname">val</td><td>Value of bytes to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a582a971525cd30c573fb0b500ca3f893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append content of a buffer to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer. </td></tr>
    <tr><td class="paramname">count</td><td>Size of the buff. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="ae9fe2c388fe0bcd0481c4f3995378e92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a C-style string to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a42fce2de666975efdf5a43c3f83588dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> content to the end of the data. </p>
<p>This function appends contents between <code>other.begin() + offset</code> and <code>other.begin() + offset + count</code> to the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset of the content in <code>other</code>. </td></tr>
    <tr><td class="paramname">count</td><td>Size of the content in <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a59649d58496900eec19401d4bbf66379"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> content to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="ac36f7b090637b8ef13bb73c98fa1648f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this object to manage a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer </td></tr>
    <tr><td class="paramname">capacity</td><td>Size of bytes that this object can manipulate. It could be different from the real allocated size of <code>buf</code>. </td></tr>
    <tr><td class="paramname">size</td><td>Size of used bytes. It should be no more that <code>capacity</code>, otherwise <code>capacity</code> will be used instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to itself </dd></dl>

</div>
</div>
<a class="anchor" id="a2f96a2ee0139645f35677e3a7bdac40a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this object to manage a buffer from another object. </p>
<p>These two objects will manipulate the same byte buffer, so if one changes the content of the buffer, the other will reflect the change. But they can have different <code>size</code>, for example, one can <code>resize</code> to a new size, the other object's <code>size</code> won't get affected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to itself </dd></dl>

</div>
</div>
<a class="anchor" id="a4c734d4c31f8f6daee91a312f10177eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a certain byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference of the byte </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>i</code> exceed <code>size</code>, an <em>exception</em> will be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d85b488caebcb1249575bdb5d7d783c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a certain byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the byte </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>i</code> exceed <code>size</code>, an <em>exception</em> will be thrown. </dd></dl>

</div>
</div>
<a class="anchor" id="a436dab00f0858a7c1dd2fc9a54323316"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last byte. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the back byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f9b703403b69fb2484de83f4d42b5f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the last byte. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the last byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a33b71fcdbac5bb363ed576a9101d18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the beginning of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An mutable iterator pointing to the beginning of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ca8affe0a06e5b0356a74dc69705b98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the beginning of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator pointing to the beginning of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a1197c2e4bec02fb3e24994596846c60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying C-style string. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#a6ebc5fd002e96535aad2ca22e50a295d" title="Get the data pointer. ">data</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d6be15af1bdbf1497afc3823e4eac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the capacity of the underlying byte buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of bytes that this object can hold at most. </dd></dl>

</div>
</div>
<a class="anchor" id="a196c7982d8f0b27435856444d13ad96f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty the data. </p>
<p>This function will <em>NOT</em> change the content of the underlying byte buffer, only reset <code>size</code> of this object. </p>

</div>
</div>
<a class="anchor" id="ab8c0bf8234ec5194abf3f3a3dbd2e573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a range of bytes with a buffer lexicographically. </p>
<p>This function compares content between <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>, with content between <code>buf</code> and <code>buf + count</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position in self to compare. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes in self to compare. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer to compare with. </td></tr>
    <tr><td class="paramname">newCount</td><td>Length of <code>buf</code> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if the first content is <em>less</em> than the second; </li>
<li><code>0</code> if two contents are equal; </li>
<li>Positive value if the first content is <em>greater</em> than the second; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a80bb071ebca96f446bf9ad462d7f61af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a range of bytes with a C-style string lexicographically. </p>
<p>This function compares content between <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>, with content of <code>buf</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position in self to compare. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes in self to compare. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if the first content is <em>less</em> than the second; </li>
<li><code>0</code> if two contents are equal; </li>
<li>Positive value if the first content is <em>greater</em> than the second; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae9e3805bfd15d4b0de2c8d93d0b0eda8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare self with a C-style string lexicographically. </p>
<p>This function compares content between <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a></code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#aa73fdbacae3841153c1a5091e86b04da" title="Get the ending of the data. ">end()</a></code>, with content of <code>buf</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if the first content is <em>less</em> than the second; </li>
<li><code>0</code> if two contents are equal; </li>
<li>Positive value if the first content is <em>greater</em> than the second; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a319aefb3eec8692f0cbc21d84cbbc6b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a range of bytes with another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </p>
<p>This function compares content between <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>, with content between <code>other.begin() + newOffset</code> and <code>other.begin() + newOffset + newCount</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position in self to compare. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes in self to compare. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object to compare with. </td></tr>
    <tr><td class="paramname">newOffset</td><td>Start position in <code>other</code> to compare with. </td></tr>
    <tr><td class="paramname">newCount</td><td>Size of bytes in <code>other</code> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if the first content is <em>less</em> than the second; </li>
<li><code>0</code> if two contents are equal; </li>
<li>Positive value if the first content is <em>greater</em> than the second; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a718f03f339d4342762e408b83e3e05d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare a range of bytes with another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </p>
<p>This function compares content between <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>, with content between <code>other.begin()</code> and <code><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d" title="End operations for CInByteStream, COutByteStreamStrRef, COutByteStreamVecRef. ">other.end()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position in self to compare. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes in self to compare. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if the first content is <em>less</em> than the second; </li>
<li><code>0</code> if two contents are equal; </li>
<li>Positive value if the first content is <em>greater</em> than the second; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aae7c5cdc8bef8996ab0e88f93446bfe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare self with another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </p>
<p>This function compares content between <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a></code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#aa73fdbacae3841153c1a5091e86b04da" title="Get the ending of the data. ">end()</a></code>, with content between <code>other.begin()</code> and <code><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d" title="End operations for CInByteStream, COutByteStreamStrRef, COutByteStreamVecRef. ">other.end()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Negative value if the first content is <em>less</em> than the second; </li>
<li><code>0</code> if two contents are equal; </li>
<li>Positive value if the first content is <em>greater</em> than the second; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afb90d96d78619f5c75041bdbe5dddbac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy content of a buffer to self. </p>
<p>This function tries to copy at most <code>count</code> bytes from <code>buf</code>, to the buffer managed by this object, starting from <code>offset</code>, which is similar to: </p><div class="fragment"><div class="line">std::copy(buf, buf + count, this-&gt;<a class="code" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18">begin</a>() + offset); </div></div><!-- fragment --><p> except that if self cannot hold as many as <code>count</code> bytes from <code>offset</code>, it will copy less bytes, which will be indicated in the return value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to copy from <code>buf</code>. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset of destination in self. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bytes actually copied. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ebc5fd002e96535aad2ca22e50a295d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#a1197c2e4bec02fb3e24994596846c60f" title="Get the underlying C-style string. ">c_str</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4c37f18778dbea654664d3e6e5c85e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the data is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>size</code> is 0; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa73fdbacae3841153c1a5091e86b04da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ending of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An mutable iterator pointing to the ending of the data, which is one position after the last used byte. </dd></dl>

</div>
</div>
<a class="anchor" id="aa420722bc2a70d025cde9c649fb53949"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ending of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An constant iterator pointing to the ending of the data, which is one position after the last used byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a4831d98d432cc17836d4ebf7580df209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start position to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>End position to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>first</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90a2ba1ede5bee5f563efdf196ad91f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position of byte to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pos</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d1de00f56d49ee81338a2a554006c1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset of start position to be erased. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self. </dd></dl>

</div>
</div>
<a class="anchor" id="aa99c62f4e79202006cd3d10553707d31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first byte. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the first byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a2317d30430067662ba201dcfc1950cb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the first byte. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the first byte. </dd></dl>

</div>
</div>
<a class="anchor" id="ac30077e16cd16842d165070ff5de9f5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a number of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Position to insert into. </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Value of bytes to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a7f360b51c215b966e5dfd9920a24b1b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the content of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Position to insert into. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer. </td></tr>
    <tr><td class="paramname">count</td><td>Length of <code>buf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a117de1aab09c34a36f535a62b80148c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a C-style string. </p>
<p>The trailing <code>'\0'</code> is <em>NOT</em> included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Position to insert into. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a1406054d49cb3b2de087da1b75b8a374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. </p>
<p>This function reads contents from <code>other.begin() + newOffset</code> to <code>other.begin() + newOffset + count</code>, and insert it to <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Position to insert into. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
    <tr><td class="paramname">newOffset</td><td>Offset of the content in <code>other</code>. </td></tr>
    <tr><td class="paramname">count</td><td>Size of the content in <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a3316d59122b319140bc2994ba699df2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Position to insert into. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a0a257d1cd75a830c530b5e31e0d0f087"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position to insert the byte. </td></tr>
    <tr><td class="paramname">val</td><td>Value of the byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>pos</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6232248ce2a504d68bd4726b0c6ad32f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the data, same as <code><a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47" title="Get the size of the data. ">size()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of used bytes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47" title="Get the size of the data. ">size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9da9367e03ee90bb7c350e7e19791837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a46e312d58883cf6bbea06eec2057117c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#a59649d58496900eec19401d4bbf66379" title="Append content of another CCharBuffer content to the end of the data. ">append(const __Myt &amp; other)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abeee7b17a26c2f8e666c0e044652d8ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a C-style string to the end of the data. </p>
<p>The trailing <code>'\0'</code> is <em>NOT</em> included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#ae9fe2c388fe0bcd0481c4f3995378e92" title="Append a C-style string to the end of the data. ">append(const_pointer buf)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c31bb24cfe95e4646ec0877eceef63f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a byte to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to append to the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#a475218796dde0a3efbbbbdce7a5f6916" title="Append a byte to the end of the data. ">push_back</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aedbe2747e0353dbe00fe3c016d07e144"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to a byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a32194cedee509bfd5bd6013bbe313493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to a byte. </dd></dl>

</div>
</div>
<a class="anchor" id="a475218796dde0a3efbbbbdce7a5f6916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a byte to the end of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to append to the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae75f2e51a4f4a0e4ef40464d6982bab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ending of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An mutable reverse iterator pointing to the ending of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a3831bc64d914c1ce9c8ab959b83ce505"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ending of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An constant reverse iterator pointing to the ending of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a633b18697ad02fd1e105a0b25116e44a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the beginning of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An mutable reverse iterator pointing to the beginning of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a26d10a386f0ed6e51dbea5a80701fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the beginning of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>An constant reverse iterator pointing to the beginning of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a6afdc05cfe65cd533aaf7f415b51f85b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with a number of new bytes. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>; </li>
<li>Insert new contents to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>;</li>
</ul>
<p>The size of the data may change if <code>count</code> is not equal to <code>newCount</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position of bytes to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to be replaced. </td></tr>
    <tr><td class="paramname">newCount</td><td>Number of new bytes. </td></tr>
    <tr><td class="paramname">val</td><td>Value of new bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a2e6aa614be0b19de1c3504bf7ce510ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of a byte buffer. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>; </li>
<li>Insert new contents to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>;</li>
</ul>
<p>The size of the data may change if <code>count</code> is not equal to <code>newCount</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position of bytes to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to be replaced. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer. </td></tr>
    <tr><td class="paramname">newCount</td><td>Length of <code>buf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a6a82d12b950a1b90c7ebdf7b9d4c97d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of a C-style string. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>; </li>
<li>Insert new contents to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>;</li>
</ul>
<p>The size of the data may change if <code>count</code> is not equal to the length of <code>buf</code>. <br />
 The trailing <code>'\0'</code> of <code>buf</code> is not included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position of bytes to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to be replaced. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a62917f71afa12f21713105b2645c9068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>newCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>; </li>
<li>Insert new contents to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>;</li>
</ul>
<p>The size of the data may change if <code>count</code> is not equal to <code>newCount</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position of bytes to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to be replaced. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
    <tr><td class="paramname">newOffset</td><td>Offset of content in <code>other</code>. </td></tr>
    <tr><td class="paramname">newCount</td><td>Size of content in <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a19c682c1eb36aa84e279b68ef5ec9202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code> to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset + count</code>; </li>
<li>Insert new contents to <code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>;</li>
</ul>
<p>The size of the data may change if <code>count</code> is not equal to <code>other.size()</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Start position of bytes to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>Size of bytes to be replaced. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="ab315f3454acae8bdc099eeafcc7af95d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with a number of new bytes. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code>first</code> to <code>last</code>; </li>
<li>Insert new contents to <code>first</code>;</li>
</ul>
<p>The size of the data may change if <code>last - first</code> is not equal to <code>count</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start position to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>End position to be replaced. </td></tr>
    <tr><td class="paramname">count</td><td>Number of new bytes. </td></tr>
    <tr><td class="paramname">val</td><td>Value of new bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a755e4c5d2b34806f8abed0ecf1742107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of a byte buffer. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code>first</code> to <code>last</code>; </li>
<li>Insert new contents to <code>first</code>;</li>
</ul>
<p>The size of the data may change if <code>last - first</code> is not equal to <code>count</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start position to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>End position to be replaced. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a byte buffer. </td></tr>
    <tr><td class="paramname">newCount</td><td>Length of <code>buf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a08ec53885360699fe8de2ebc2a21b633"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_pointer&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of a C-style string. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code>first</code> to <code>last</code>; </li>
<li>Insert new contents to <code>first</code>;</li>
</ul>
<p>The size of the data may change if <code>last - first</code> is not equal to the length of <code>buf</code>. <br />
 The trailing <code>'\0'</code> of <code>buf</code> is not included. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start position to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>End position to be replaced. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a42219269dcda027fe9b7be963d3d3ca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code>first</code> to <code>last</code>; </li>
<li>Insert new contents to <code>first</code>;</li>
</ul>
<p>The size of the data may change if <code>last - first</code> is not equal to <code>count</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start position to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>End position to be replaced. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset of content in <code>other</code>. </td></tr>
    <tr><td class="paramname">count</td><td>Size of content in <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="a733cdaa5755bf99b41b37bc973dca133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a>&amp; <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a range of bytes with the content of another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a>. </p>
<p>This function performs actions similar to the following: </p><ul>
<li>Erasing contents from <code>first</code> to <code>last</code>; </li>
<li>Insert new contents to <code>first</code>;</li>
</ul>
<p>The size of the data may change if <code>last - first</code> is not equal to <code>other.size()</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start position to be replaced. </td></tr>
    <tr><td class="paramname">last</td><td>End position to be replaced. </td></tr>
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to self </dd></dl>

</div>
</div>
<a class="anchor" id="ab37819fe64b068ba3ef9f9beb9645ae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the data. </p>
<p>If data shrinks, no change will be made to the content of the underlying buffer. If data expands, new data will be filled with <code>val</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>New size of the data </td></tr>
    <tr><td class="paramname">val</td><td>Value to fill in the expanded data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15e396e7316d367069e7a1a5c761ba47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the data. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of used bytes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCCharBuffer.html#a6232248ce2a504d68bd4726b0c6ad32f" title="Get the size of the data, same as size(). ">length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a85654201646d22b7a162a4fa69bdeed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCCharBuffer.html">__Myt</a> <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::substr </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a substring. </p>
<p>The substring has the following attributes: </p><ul>
<li><code><a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a></code> is equal to <code>this-&gt;<a class="el" href="classCCharBuffer.html#a0a33b71fcdbac5bb363ed576a9101d18" title="Get the beginning of the data. ">begin()</a> + offset</code>; </li>
<li><code><a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47" title="Get the size of the data. ">size()</a></code> is equal to the smaller one of <code>count</code> and <code>this-&gt;<a class="el" href="classCCharBuffer.html#a15e396e7316d367069e7a1a5c761ba47" title="Get the size of the data. ">size()</a> - offset</code>; </li>
<li><code><a class="el" href="classCCharBuffer.html#ad1d6be15af1bdbf1497afc3823e4eac6" title="Get the capacity of the underlying byte buffer. ">capacity()</a></code> is equal to <code>this-&gt;<a class="el" href="classCCharBuffer.html#ad1d6be15af1bdbf1497afc3823e4eac6" title="Get the capacity of the underlying byte buffer. ">capacity()</a> - offset</code>; <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset of start position of the substring. </td></tr>
    <tr><td class="paramname">count</td><td>Length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> object denote the substring. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ae382ca22e252780a7689470e90d8f36c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCCharBuffer.html">CCharBuffer</a>&lt; CharT &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCCharBuffer.html">__Myt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two <a class="el" href="classCCharBuffer.html" title="Provide interfaces similar to std::string for raw byte array. ">CCharBuffer</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Reference to another object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="char__buffer_8hh_source.html">char_buffer.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
