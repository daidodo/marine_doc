<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Marine Library: CAtomicHashTable&lt; Key, HashKey, EqualKey &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marine Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for Linux Networking Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classCAtomicHashTable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CAtomicHashTable&lt; Key, HashKey, EqualKey &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A lock-free hash table that can be used in multi-thread or multi-process programs.  
 <a href="classCAtomicHashTable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="atomic__hash__table_8hh_source.html">atomic_hash_table.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7fda30db560d69bcc9e243edc16d9d02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fda30db560d69bcc9e243edc16d9d02"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a7fda30db560d69bcc9e243edc16d9d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667af68f3b6f285378bdfcf35aec6315"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a667af68f3b6f285378bdfcf35aec6315"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a667af68f3b6f285378bdfcf35aec6315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c902be03caf62923c01f4b7b8750ea8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c902be03caf62923c01f4b7b8750ea8"></a>
typedef EqualKey&lt; key_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b></td></tr>
<tr class="separator:a3c902be03caf62923c01f4b7b8750ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25865e3af8caef1216cabf040d04e901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25865e3af8caef1216cabf040d04e901"></a>
typedef HashKey&lt; typename <a class="el" href="structCOmitCV.html">COmitCV</a>&lt; key_type &gt;::result_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b></td></tr>
<tr class="separator:a25865e3af8caef1216cabf040d04e901"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff1a422fd8b5b9fc2b42a183d2d71611"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aff1a422fd8b5b9fc2b42a183d2d71611">CAtomicHashTable</a> ()</td></tr>
<tr class="memdesc:aff1a422fd8b5b9fc2b42a183d2d71611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare an uninitialized object.  <a href="#aff1a422fd8b5b9fc2b42a183d2d71611">More...</a><br /></td></tr>
<tr class="separator:aff1a422fd8b5b9fc2b42a183d2d71611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab575fe549c2375ddeed85520db39f3b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#ab575fe549c2375ddeed85520db39f3b4">CAtomicHashTable</a> (char *buf, size_t sz)</td></tr>
<tr class="memdesc:ab575fe549c2375ddeed85520db39f3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to an existing hash table hosted in a memory buffer.  <a href="#ab575fe549c2375ddeed85520db39f3b4">More...</a><br /></td></tr>
<tr class="separator:ab575fe549c2375ddeed85520db39f3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f14c9eb8da82c9bf3cba28c3d1a8a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a84f14c9eb8da82c9bf3cba28c3d1a8a5">CAtomicHashTable</a> (char *buf, size_t sz, size_t <a class="el" href="classCAtomicHashTable.html#aa7311ba69ad57242f6fb039fc06c0167">capacity</a>, int row, size_t valueLen, bool create=false)</td></tr>
<tr class="memdesc:a84f14c9eb8da82c9bf3cba28c3d1a8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to or create a hash table in a memory buffer.  <a href="#a84f14c9eb8da82c9bf3cba28c3d1a8a5">More...</a><br /></td></tr>
<tr class="separator:a84f14c9eb8da82c9bf3cba28c3d1a8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6490bc5f28514b9c15ad23e4e0bcf2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#ad6490bc5f28514b9c15ad23e4e0bcf2a">init</a> (char *buf, size_t sz)</td></tr>
<tr class="memdesc:ad6490bc5f28514b9c15ad23e4e0bcf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to an existing hash table hosted in a memory buffer.  <a href="#ad6490bc5f28514b9c15ad23e4e0bcf2a">More...</a><br /></td></tr>
<tr class="separator:ad6490bc5f28514b9c15ad23e4e0bcf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae04b8783d73a0658e93968b6f52d97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aeae04b8783d73a0658e93968b6f52d97">init</a> (char *buf, size_t sz, size_t <a class="el" href="classCAtomicHashTable.html#aa7311ba69ad57242f6fb039fc06c0167">capacity</a>, int row, size_t valueLen, bool create=false)</td></tr>
<tr class="memdesc:aeae04b8783d73a0658e93968b6f52d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to or create a hash table in a memory buffer.  <a href="#aeae04b8783d73a0658e93968b6f52d97">More...</a><br /></td></tr>
<tr class="separator:aeae04b8783d73a0658e93968b6f52d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51ad9a839f4585659a6cbbd853a79eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#af51ad9a839f4585659a6cbbd853a79eb">uninit</a> ()</td></tr>
<tr class="memdesc:af51ad9a839f4585659a6cbbd853a79eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset current object.  <a href="#af51ad9a839f4585659a6cbbd853a79eb">More...</a><br /></td></tr>
<tr class="separator:af51ad9a839f4585659a6cbbd853a79eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fece08b235c820664358dd6faccc5c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a9fece08b235c820664358dd6faccc5c3">valid</a> () const </td></tr>
<tr class="memdesc:a9fece08b235c820664358dd6faccc5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if current object is initialized.  <a href="#a9fece08b235c820664358dd6faccc5c3">More...</a><br /></td></tr>
<tr class="separator:a9fece08b235c820664358dd6faccc5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a63e8841a5f703c4c7df4e61bb4b06bd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a63e8841a5f703c4c7df4e61bb4b06bd9">rowSize</a> () const </td></tr>
<tr class="memdesc:a63e8841a5f703c4c7df4e61bb4b06bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of rows in hash table.  <a href="#a63e8841a5f703c4c7df4e61bb4b06bd9">More...</a><br /></td></tr>
<tr class="separator:a63e8841a5f703c4c7df4e61bb4b06bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc95bdc7fce642d6e51ff63c182764d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a9bc95bdc7fce642d6e51ff63c182764d">capacityOfRow</a> (int row) const </td></tr>
<tr class="memdesc:a9bc95bdc7fce642d6e51ff63c182764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get capacity of a row in hash table.  <a href="#a9bc95bdc7fce642d6e51ff63c182764d">More...</a><br /></td></tr>
<tr class="separator:a9bc95bdc7fce642d6e51ff63c182764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7311ba69ad57242f6fb039fc06c0167"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aa7311ba69ad57242f6fb039fc06c0167">capacity</a> () const </td></tr>
<tr class="memdesc:aa7311ba69ad57242f6fb039fc06c0167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get capacity of the hash table.  <a href="#aa7311ba69ad57242f6fb039fc06c0167">More...</a><br /></td></tr>
<tr class="separator:aa7311ba69ad57242f6fb039fc06c0167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ad5ed43a00c8d9efaa7fa51d14136e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a73ad5ed43a00c8d9efaa7fa51d14136e">sizeOfRow</a> (int row) const </td></tr>
<tr class="memdesc:a73ad5ed43a00c8d9efaa7fa51d14136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of key-value pairs in a row.  <a href="#a73ad5ed43a00c8d9efaa7fa51d14136e">More...</a><br /></td></tr>
<tr class="separator:a73ad5ed43a00c8d9efaa7fa51d14136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5bad7de33ec9a0933561b9285d6bdc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aab5bad7de33ec9a0933561b9285d6bdc">size</a> () const </td></tr>
<tr class="memdesc:aab5bad7de33ec9a0933561b9285d6bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of key-value pair in the hash table.  <a href="#aab5bad7de33ec9a0933561b9285d6bdc">More...</a><br /></td></tr>
<tr class="separator:aab5bad7de33ec9a0933561b9285d6bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda2ff5b81714f97b3bed58198db8b60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aeda2ff5b81714f97b3bed58198db8b60">empty</a> () const </td></tr>
<tr class="memdesc:aeda2ff5b81714f97b3bed58198db8b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the hash table is empty.  <a href="#aeda2ff5b81714f97b3bed58198db8b60">More...</a><br /></td></tr>
<tr class="separator:aeda2ff5b81714f97b3bed58198db8b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Brief Info</div></td></tr>
<tr class="memitem:a5f84c07c633be50f5b23bd46b4e8c20b"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a5f84c07c633be50f5b23bd46b4e8c20b">createTime</a> () const </td></tr>
<tr class="memdesc:a5f84c07c633be50f5b23bd46b4e8c20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation time of the hash table.  <a href="#a5f84c07c633be50f5b23bd46b4e8c20b">More...</a><br /></td></tr>
<tr class="separator:a5f84c07c633be50f5b23bd46b4e8c20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4031f2ab0f4cbd2f5361c447b569a"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aa5c4031f2ab0f4cbd2f5361c447b569a">updateTime</a> () const </td></tr>
<tr class="memdesc:aa5c4031f2ab0f4cbd2f5361c447b569a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get latest updating time of the hash table.  <a href="#aa5c4031f2ab0f4cbd2f5361c447b569a">More...</a><br /></td></tr>
<tr class="separator:aa5c4031f2ab0f4cbd2f5361c447b569a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a8e143d2b372d16f950ce9642826b1"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a77a8e143d2b372d16f950ce9642826b1">upgradeTime</a> () const </td></tr>
<tr class="memdesc:a77a8e143d2b372d16f950ce9642826b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get latest upgrading time of the hash table.  <a href="#a77a8e143d2b372d16f950ce9642826b1">More...</a><br /></td></tr>
<tr class="separator:a77a8e143d2b372d16f950ce9642826b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b5670b1a9af0e5f07a12b187d3799b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a78b5670b1a9af0e5f07a12b187d3799b">toString</a> () const </td></tr>
<tr class="memdesc:a78b5670b1a9af0e5f07a12b187d3799b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a description of the hash table.  <a href="#a78b5670b1a9af0e5f07a12b187d3799b">More...</a><br /></td></tr>
<tr class="separator:a78b5670b1a9af0e5f07a12b187d3799b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Access</div></td></tr>
<tr class="memitem:aa16876ecf5e923a058022242e82b5d0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aa16876ecf5e923a058022242e82b5d0a">insert</a> (const key_type &amp;key, const char *value, size_t len)</td></tr>
<tr class="memdesc:aa16876ecf5e923a058022242e82b5d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair into the hash table.  <a href="#aa16876ecf5e923a058022242e82b5d0a">More...</a><br /></td></tr>
<tr class="separator:aa16876ecf5e923a058022242e82b5d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4077fbcef7c0fe466dfcef223f1fab7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a4077fbcef7c0fe466dfcef223f1fab7d">insert</a> (const key_type &amp;key, const std::string &amp;value)</td></tr>
<tr class="memdesc:a4077fbcef7c0fe466dfcef223f1fab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair into the hash table.  <a href="#a4077fbcef7c0fe466dfcef223f1fab7d">More...</a><br /></td></tr>
<tr class="separator:a4077fbcef7c0fe466dfcef223f1fab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d1f8c49751a75ab12b4aa89812c5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a772d1f8c49751a75ab12b4aa89812c5c">get</a> (const key_type &amp;key, char *value, size_t &amp;len) const </td></tr>
<tr class="memdesc:a772d1f8c49751a75ab12b4aa89812c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain value of a key.  <a href="#a772d1f8c49751a75ab12b4aa89812c5c">More...</a><br /></td></tr>
<tr class="separator:a772d1f8c49751a75ab12b4aa89812c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf0b46d6854bd17b92888207bbbf667"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#abdf0b46d6854bd17b92888207bbbf667">get</a> (const key_type &amp;key, std::string &amp;value) const </td></tr>
<tr class="memdesc:abdf0b46d6854bd17b92888207bbbf667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain value of a key.  <a href="#abdf0b46d6854bd17b92888207bbbf667">More...</a><br /></td></tr>
<tr class="separator:abdf0b46d6854bd17b92888207bbbf667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadd8d8ca75dcfc6d3c407db0fede31b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#acadd8d8ca75dcfc6d3c407db0fede31b">has</a> (const key_type &amp;key) const </td></tr>
<tr class="memdesc:acadd8d8ca75dcfc6d3c407db0fede31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a key exists in the hash table.  <a href="#acadd8d8ca75dcfc6d3c407db0fede31b">More...</a><br /></td></tr>
<tr class="separator:acadd8d8ca75dcfc6d3c407db0fede31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae57ecbd78dbee1819d6f72eb8bfd373"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#aae57ecbd78dbee1819d6f72eb8bfd373">update</a> (const key_type &amp;key, const char *value, size_t len)</td></tr>
<tr class="memdesc:aae57ecbd78dbee1819d6f72eb8bfd373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update value of a key.  <a href="#aae57ecbd78dbee1819d6f72eb8bfd373">More...</a><br /></td></tr>
<tr class="separator:aae57ecbd78dbee1819d6f72eb8bfd373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c0fc4da0c553ed0efed5a00abc67b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a801c0fc4da0c553ed0efed5a00abc67b">update</a> (const key_type &amp;key, const std::string &amp;value)</td></tr>
<tr class="memdesc:a801c0fc4da0c553ed0efed5a00abc67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update value of a key.  <a href="#a801c0fc4da0c553ed0efed5a00abc67b">More...</a><br /></td></tr>
<tr class="separator:a801c0fc4da0c553ed0efed5a00abc67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ca10d7fb29f09945b94859aa6bbf7b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a22ca10d7fb29f09945b94859aa6bbf7b">remove</a> (const key_type &amp;key)</td></tr>
<tr class="memdesc:a22ca10d7fb29f09945b94859aa6bbf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a key and its value.  <a href="#a22ca10d7fb29f09945b94859aa6bbf7b">More...</a><br /></td></tr>
<tr class="separator:a22ca10d7fb29f09945b94859aa6bbf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c08beefde17362a0333544f3619ac52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a3c08beefde17362a0333544f3619ac52">clear</a> ()</td></tr>
<tr class="memdesc:a3c08beefde17362a0333544f3619ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all data in the hash table.  <a href="#a3c08beefde17362a0333544f3619ac52">More...</a><br /></td></tr>
<tr class="separator:a3c08beefde17362a0333544f3619ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8d5a2084abb992973cf3ba5b8ea8718c"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a8d5a2084abb992973cf3ba5b8ea8718c">CalcBufSize</a> (size_t <a class="el" href="classCAtomicHashTable.html#aa7311ba69ad57242f6fb039fc06c0167">capacity</a>, int row, size_t valueLen)</td></tr>
<tr class="memdesc:a8d5a2084abb992973cf3ba5b8ea8718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute memory size needed for a hash table.  <a href="#a8d5a2084abb992973cf3ba5b8ea8718c">More...</a><br /></td></tr>
<tr class="separator:a8d5a2084abb992973cf3ba5b8ea8718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8ee03d5c258630724ec48021545ae4cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee03d5c258630724ec48021545ae4cc"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCAtomicHashTable.html#a8ee03d5c258630724ec48021545ae4cc">kValueLenMax</a> = (1UL &lt;&lt; 24)</td></tr>
<tr class="memdesc:a8ee03d5c258630724ec48021545ae4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of <em>Key</em> plus <em>Value</em>, i.e. 16MB. <br /></td></tr>
<tr class="separator:a8ee03d5c258630724ec48021545ae4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt;<br />
class CAtomicHashTable&lt; Key, HashKey, EqualKey &gt;</h3>

<p>A lock-free hash table that can be used in multi-thread or multi-process programs. </p>
<p>A common usage of <a class="el" href="classCAtomicHashTable.html" title="A lock-free hash table that can be used in multi-thread or multi-process programs. ">CAtomicHashTable</a> is for multiple threads or processes to operate on the same hash table efficiently. <br />
 It must reside in continuous memory pre-allocated by the user. Hence, key and value types must be <a href="http://en.cppreference.com/w/cpp/types/is_trivially_copyable">trivially copyable</a>, i.e. can be copied using <code>std::memcpy</code>. </p><dl class="section user"><dt>Multi-Thread/Process Safety Guide</dt><dd><table class="doxtable">
<tr>
<th></th><th>Same Key </th><th>Different Keys  </th></tr>
<tr>
<td><b>Read</b> </td><td>Safe </td><td>Safe </td></tr>
<tr>
<td><b>Write</b> </td><td>Unsafe </td><td>Safe </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Multiple Rows Hash Table</dt><dd><a class="el" href="classCAtomicHashTable.html" title="A lock-free hash table that can be used in multi-thread or multi-process programs. ">CAtomicHashTable</a> resolves key hash collisions by adding multiple rows. A row is a one-dimension hash table. <br />
 If a key collides with another key in a row, <a class="el" href="classCAtomicHashTable.html" title="A lock-free hash table that can be used in multi-thread or multi-process programs. ">CAtomicHashTable</a> will search in the next row, and so on until it finds a room. <br />
 The more number of rows, the less chance of failure when hash table capacity is about to reach. The less number of rows, the better performance it can get. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Type of keys, must be POD or C struct compatible types </td></tr>
    <tr><td class="paramname">HashKey</td><td>Hash function of <em>Key</em>, should implement: <div class="fragment"><div class="line"><span class="keywordtype">size_t</span> operator ()(<span class="keyword">const</span> Key &amp; key) <span class="keyword">const</span>;  <span class="comment">// compute hash value of key </span></div></div><!-- fragment --> </td></tr>
    <tr><td class="paramname">EqualKey</td><td>Equal predictor of <em>Key</em>, should implement: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator ()(<span class="keyword">const</span> Key &amp; key1, <span class="keyword">const</span> Key &amp; key2) <span class="keyword">const</span>;  <span class="comment">// predict if key1 == key2</span></div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Value</dt><dd>Value type is <code>std::string</code> or <code>char</code> array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Size limitation of <em>Key</em> and <em>Value</em> is defined by <a class="el" href="classCAtomicHashTable.html#a8ee03d5c258630724ec48021545ae4cc">kValueLenMax</a>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aff1a422fd8b5b9fc2b42a183d2d71611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::<a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare an uninitialized object. </p>
<p>You cannot use the object until it is initialized by <a class="el" href="classCAtomicHashTable.html#ad6490bc5f28514b9c15ad23e4e0bcf2a">init</a>. </p>

</div>
</div>
<a class="anchor" id="ab575fe549c2375ddeed85520db39f3b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::<a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to an existing hash table hosted in a memory buffer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCAtomicHashTable.html#ad6490bc5f28514b9c15ad23e4e0bcf2a" title="Attach to an existing hash table hosted in a memory buffer. ">init(char * buf, size_t sz)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a84f14c9eb8da82c9bf3cba28c3d1a8a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::<a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to or create a hash table in a memory buffer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCAtomicHashTable.html#aeae04b8783d73a0658e93968b6f52d97" title="Attach to or create a hash table in a memory buffer. ">init(char * buf, size_t sz, size_t capacity, int row, size_t valueLen, bool create)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8d5a2084abb992973cf3ba5b8ea8718c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::CalcBufSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute memory size needed for a hash table. </p>
<p>This function pre-computes the size of pre-allocated memory buffer needed for a hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The maximum number of key-value pairs the hash table wishes to hold </td></tr>
    <tr><td class="paramname">row</td><td>Number of rows the hash table wants to have </td></tr>
    <tr><td class="paramname">valueLen</td><td>Estimated byte size of key plus value, e.g. average size. This needs <em>NOT</em> to be the maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Number of bytes needed for a memory buffer to hold the hash table </li>
<li>Or 0 if such requirement is unable to meet </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classCAtomicHashTable.html" title="A lock-free hash table that can be used in multi-thread or multi-process programs. ">CAtomicHashTable</a> stores data (key and value) in <em>blocks</em> of size <code>valueLen</code>. If the block size is too large, there will be a lot of wasted spaces inside each block. Otherwise, if the block size is too small, a data may spread to many blocks, which will impact access performance. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7311ba69ad57242f6fb039fc06c0167"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get capacity of the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Number of key-value pairs that this hash table can hold at most </li>
<li>Or 0 if current object is NOT initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9bc95bdc7fce642d6e51ff63c182764d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::capacityOfRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get capacity of a row in hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Index of row, ranging from 0 to <a class="el" href="classCAtomicHashTable.html#a63e8841a5f703c4c7df4e61bb4b06bd9" title="Get number of rows in hash table. ">rowSize()</a> - 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of key-value pairs that this row can hold at most </dd></dl>

</div>
</div>
<a class="anchor" id="a3c08beefde17362a0333544f3619ac52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all data in the hash table. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is <em>NOT</em> thread-safe. Do <em>NOT</em> call it while other threads or processes are accessing the hash table. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f84c07c633be50f5b23bd46b4e8c20b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::createTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get creation time of the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Creation time of this hash table </li>
<li>Or 0 if current object is NOT initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aeda2ff5b81714f97b3bed58198db8b60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the hash table is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hash table is empty; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a772d1f8c49751a75ab12b4aa89812c5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain value of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to search for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Pointer to memory buffer that receives the value data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Passed in as bytes size of <code>value</code> buffer; and passed out as actual bytes size of the data copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>true</code>, if succeeded </li>
<li><code>false</code>, otherwise, e.g. <code>key</code> doesn't exists, <code>value</code> buffer is insufficient </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abdf0b46d6854bd17b92888207bbbf667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain value of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to search for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>String bytes to receive the value data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="acadd8d8ca75dcfc6d3c407db0fede31b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::has </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a key exists in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>key</code> exists in this hash table; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6490bc5f28514b9c15ad23e4e0bcf2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::init </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to an existing hash table hosted in a memory buffer. </p>
<p>There must be an initialized hash table in the memory buffer. This function tries to attach to the existing hash table to a local object. If failed, it won't modify the content of the memory buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the memory buffer </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of the memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aeae04b8783d73a0658e93968b6f52d97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::init </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach to or create a hash table in a memory buffer. </p>
<ul>
<li>if <code>create = false</code>, this function tries to attach to an existing hash table in the memory buffer to a local object, just like <a class="el" href="classCAtomicHashTable.html#ad6490bc5f28514b9c15ad23e4e0bcf2a" title="Attach to an existing hash table hosted in a memory buffer. ">init(char * buf, size_t sz)</a>, except that it will also validate <code>capacity</code>, <code>row</code> and <code>valueLen</code> parameters if they are not 0; </li>
<li>if <code>create = true</code>, this function will create a new hash table in the memory buffer, and erase any data existing. In this case, <code>sz</code> should be the return value of <a class="el" href="classCAtomicHashTable.html#a8d5a2084abb992973cf3ba5b8ea8718c">CalcBufSize</a>, otherwise this function may fail.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the memory buffer </td></tr>
    <tr><td class="paramname">sz</td><td>Byte size of the memory buffer </td></tr>
    <tr><td class="paramname">capacity</td><td>The maximum number of key-value pairs the hash table wishes to hold </td></tr>
    <tr><td class="paramname">row</td><td>Number of rows the hash table wants to have </td></tr>
    <tr><td class="paramname">valueLen</td><td>Estimated byte size of key plus value, e.g. average size. This needs <em>NOT</em> to be the maximum. </td></tr>
    <tr><td class="paramname">create</td><td><code>false</code> if attached to an existing hash table; <code>true</code> if create a new one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCAtomicHashTable.html#a8d5a2084abb992973cf3ba5b8ea8718c" title="Compute memory size needed for a hash table. ">CalcBufSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa16876ecf5e923a058022242e82b5d0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair into the hash table. </p>
<p>If <code>key</code> already exists, this function may result in multiple instances of <code>key</code> in the hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to insert into the hash table </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to bytes of value to insert into the hash table </td></tr>
    <tr><td class="paramname">len</td><td>Byte size of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a4077fbcef7c0fe466dfcef223f1fab7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair into the hash table. </p>
<p>If <code>key</code> already exists, this function may result in multiple instances of <code>key</code> in the hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to insert into the hash table </td></tr>
    <tr><td class="paramname">value</td><td>Bytes of value to insert into the hash table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a22ca10d7fb29f09945b94859aa6bbf7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a key and its value. </p>
<p>If there are multiple instances of <code>key</code>, only one will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to remove from this hash table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of data blocks released; Or 0 if <code>key</code> doesn't exist </dd></dl>

</div>
</div>
<a class="anchor" id="a63e8841a5f703c4c7df4e61bb4b06bd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::rowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of rows in hash table. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Number of rows </li>
<li>Or 0 if current object is NOT initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aab5bad7de33ec9a0933561b9285d6bdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of key-value pair in the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of key-value pairs in this hash table </dd></dl>

</div>
</div>
<a class="anchor" id="a73ad5ed43a00c8d9efaa7fa51d14136e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::sizeOfRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of key-value pairs in a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>Index of row, ranging from 0 to <a class="el" href="classCAtomicHashTable.html#a63e8841a5f703c4c7df4e61bb4b06bd9" title="Get number of rows in hash table. ">rowSize()</a> - 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of key-value pairs hosted in this row </dd></dl>

</div>
</div>
<a class="anchor" id="a78b5670b1a9af0e5f07a12b187d3799b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a description of the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>A human readable description of this hash table </dd></dl>

</div>
</div>
<a class="anchor" id="af51ad9a839f4585659a6cbbd853a79eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::uninit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset current object. </p>
<p>This function won't affect data in the real hash table memory buffer. After reset, the local object could be reused by <a class="el" href="classCAtomicHashTable.html#ad6490bc5f28514b9c15ad23e4e0bcf2a">init</a>. </p>

</div>
</div>
<a class="anchor" id="aae57ecbd78dbee1819d6f72eb8bfd373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update value of a key. </p>
<p>If <code>key</code> doesn't exist, then insert a new key-value pair. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to search for </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to bytes of value to update for </td></tr>
    <tr><td class="paramname">len</td><td>Byte size of value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCAtomicHashTable.html#aa16876ecf5e923a058022242e82b5d0a" title="Insert a key-value pair into the hash table. ">insert</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a801c0fc4da0c553ed0efed5a00abc67b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update value of a key. </p>
<p>If <code>key</code> doesn't exist, then insert a new key-value pair. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to search for </td></tr>
    <tr><td class="paramname">value</td><td>Bytes of value to update for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if succeeded; otherwise <code>false</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCAtomicHashTable.html#aa16876ecf5e923a058022242e82b5d0a" title="Insert a key-value pair into the hash table. ">insert</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5c4031f2ab0f4cbd2f5361c447b569a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::updateTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get latest updating time of the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Latest updating time of this hash table </li>
<li>Or 0 if current object is NOT initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a77a8e143d2b372d16f950ce9642826b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::upgradeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get latest upgrading time of the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Latest upgrading time of this hash table </li>
<li>Or 0 if current object is NOT initialized </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9fece08b235c820664358dd6faccc5c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , template&lt; typename &gt;class HashKey = CHashFn, template&lt; typename &gt;class EqualKey = std::equal_to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCAtomicHashTable.html">CAtomicHashTable</a>&lt; Key, HashKey, EqualKey &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if current object is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if current object is initialized; otherwise <code>false</code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="atomic__hash__table_8hh_source.html">atomic_hash_table.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
