<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Marine Library: Manip Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Marine Library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">C++ library for Linux Networking Development</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Manip Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manipulators for stream interface APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorProtobuf&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e">protobuf</a> (T &amp;msg, size_t size=size_t(-1))</td></tr>
<tr class="memdesc:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack/unpack <a href="https://github.com/google/protobuf">Protocol Buffers</a> messages.  <a href="#a8bd14c601e489bbe9a5e9781b4606c0e">More...</a><br /></td></tr>
<tr class="separator:a8bd14c601e489bbe9a5e9781b4606c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181b437b00e3fabbfa66b62a778561f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab181b437b00e3fabbfa66b62a778561f"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorVarint&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#ab181b437b00e3fabbfa66b62a778561f">varint</a> (const T &amp;val)</td></tr>
<tr class="memdesc:ab181b437b00e3fabbfa66b62a778561f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack integer using <a href="http://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a> encoding.  <a href="#ab181b437b00e3fabbfa66b62a778561f">More...</a><br /></td></tr>
<tr class="separator:ab181b437b00e3fabbfa66b62a778561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac625510fbd47e955faa40fbcff1a8496"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac625510fbd47e955faa40fbcff1a8496"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorVarint&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#ac625510fbd47e955faa40fbcff1a8496">varint</a> (T &amp;val)</td></tr>
<tr class="memdesc:ac625510fbd47e955faa40fbcff1a8496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack integer using <a href="http://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a> encoding.  <a href="#ac625510fbd47e955faa40fbcff1a8496">More...</a><br /></td></tr>
<tr class="separator:ac625510fbd47e955faa40fbcff1a8496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9007b4269e679af40fa9f5da3ad07ca4"><td class="memItemLeft" align="right" valign="top">NS_IMPL::CManipulatorStubPush&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">stub</a> (size_t sz)</td></tr>
<tr class="memdesc:a9007b4269e679af40fa9f5da3ad07ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a stub.  <a href="#a9007b4269e679af40fa9f5da3ad07ca4">More...</a><br /></td></tr>
<tr class="separator:a9007b4269e679af40fa9f5da3ad07ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3e0d1f84519db6f53f6e77ed5eb22b"><td class="memItemLeft" align="right" valign="top">NS_IMPL::CManipulatorStubPop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a4d3e0d1f84519db6f53f6e77ed5eb22b">stub_pop</a> (bool align=false, bool check=false)</td></tr>
<tr class="memdesc:a4d3e0d1f84519db6f53f6e77ed5eb22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demolish the top most stub.  <a href="#a4d3e0d1f84519db6f53f6e77ed5eb22b">More...</a><br /></td></tr>
<tr class="separator:a4d3e0d1f84519db6f53f6e77ed5eb22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611c000a75ebf54feaf7683edd176430"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a611c000a75ebf54feaf7683edd176430"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>boolalpha</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a611c000a75ebf54feaf7683edd176430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41b2179907d505f5b1fae04256a09b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41b2179907d505f5b1fae04256a09b4"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>noboolalpha</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:ab41b2179907d505f5b1fae04256a09b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3840b6c041e818ca5e06f6cb72b2d97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3840b6c041e818ca5e06f6cb72b2d97"></a>
NS_IMPL::CToStringWidth&#160;</td><td class="memItemRight" valign="bottom"><b>setw</b> (int w)</td></tr>
<tr class="separator:af3840b6c041e818ca5e06f6cb72b2d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a85f87a75a0b2ad855aa4dfe66011b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a85f87a75a0b2ad855aa4dfe66011b"></a>
NS_IMPL::CToStringFill&#160;</td><td class="memItemRight" valign="bottom"><b>fill</b> (char c)</td></tr>
<tr class="separator:a05a85f87a75a0b2ad855aa4dfe66011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b76478d4c37d89c789dd7fb3f1240ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b76478d4c37d89c789dd7fb3f1240ac"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>left</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a2b76478d4c37d89c789dd7fb3f1240ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b56307d933c1cb2192d5fbdd7da93a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0b56307d933c1cb2192d5fbdd7da93a"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>right</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:ad0b56307d933c1cb2192d5fbdd7da93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c93a8e80954d7aecf8dec5b47ad46dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c93a8e80954d7aecf8dec5b47ad46dc"></a>
NS_IMPL::CToStringBase&#160;</td><td class="memItemRight" valign="bottom"><b>setbase</b> (int base)</td></tr>
<tr class="separator:a2c93a8e80954d7aecf8dec5b47ad46dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7c849d4b47495b64fe0725f8e15a7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf7c849d4b47495b64fe0725f8e15a7f"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>dec</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:abf7c849d4b47495b64fe0725f8e15a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90660196fa49d3a23f021aa5dbdfbc3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90660196fa49d3a23f021aa5dbdfbc3a"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>hex</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a90660196fa49d3a23f021aa5dbdfbc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29378df551cf69d261aa5daa1bff4db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29378df551cf69d261aa5daa1bff4db"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>oct</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:ac29378df551cf69d261aa5daa1bff4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76820c20bbaa2d565c9a10144d5bdedd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76820c20bbaa2d565c9a10144d5bdedd"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bin</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a76820c20bbaa2d565c9a10144d5bdedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b061603dbc3df334c2b101c45591f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31b061603dbc3df334c2b101c45591f9"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>showbase</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a31b061603dbc3df334c2b101c45591f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed541bbd979fbcf6fc4246ee754aeb45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed541bbd979fbcf6fc4246ee754aeb45"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>noshowbase</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:aed541bbd979fbcf6fc4246ee754aeb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6014ecca0803f96e4168a8e36c32fcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6014ecca0803f96e4168a8e36c32fcc"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>autocase</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:af6014ecca0803f96e4168a8e36c32fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4c2e1296e7daa21bd3c6cf003845a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4c2e1296e7daa21bd3c6cf003845a4"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>uppercase</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a9c4c2e1296e7daa21bd3c6cf003845a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2905e5ddb612471d1b81ad8ae858700"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2905e5ddb612471d1b81ad8ae858700"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nouppercase</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:aa2905e5ddb612471d1b81ad8ae858700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63580b836f26e8a0014c5eb45a49f8be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63580b836f26e8a0014c5eb45a49f8be"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>showpos</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:a63580b836f26e8a0014c5eb45a49f8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8f5ddb89961110535fc170334f1f5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec8f5ddb89961110535fc170334f1f5b"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>noshowpos</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:aec8f5ddb89961110535fc170334f1f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd490beeba9b03eec6edeb2123ba99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0cd490beeba9b03eec6edeb2123ba99"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>endl</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:ae0cd490beeba9b03eec6edeb2123ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae08da485a285c37ed2b4c5e296b8a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acae08da485a285c37ed2b4c5e296b8a2"></a>
<a class="el" href="classCToString.html">CToString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ends</b> (<a class="el" href="classCToString.html">CToString</a> &amp;tos)</td></tr>
<tr class="separator:acae08da485a285c37ed2b4c5e296b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapip::raw</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Pack/unpack a range of elements, <em>without</em> leading size field.</p>
<p><code>Mapip::raw</code> is convenient for pack/unpack fixed number of elements, like an array, a string of characters, or a container. </p><dl class="section user"><dt>Array</dt><dd>Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[5];    <span class="comment">// an array to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c);  <span class="comment">// unpack 5 integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; 5;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[5];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c);    <span class="comment">// pack 5 integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; 5;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> If size of array cannot be deduced automatically, a parameter must be provided. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];    <span class="comment">// an array to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, sz);  <span class="comment">// unpack &#39;sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c, sz);    <span class="comment">// pack &#39;sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Containers</dt><dd>Most STL containers are well supported, e.g. <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set/multiset</code>, <code>map/multimap</code>, etc. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// a container to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, sz);  <span class="comment">// unpack &#39;sz&#39; integers, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0, v;i &lt; sz;++i){</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.insert(c.end(), v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// an vector to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c);    <span class="comment">// pack all elements in &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>String</dt><dd>A C-style string is essentially an array of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> * c = <span class="keyword">new</span> <span class="keywordtype">char</span>[sz];    <span class="comment">// an array of chars to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, sz);  <span class="comment">// unpack &#39;sz&#39; chars</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a C-style string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c, strlen(c));    <span class="comment">// pack a C-style string</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; strlen(c);++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> <br />
 An <code>std::string</code> is a container of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c;    <span class="comment">// an object to receive unpacked data</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(c, len);  <span class="comment">// unpack &#39;len&#39; bytes of data, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; len;++i){</span></div><div class="line"><span class="comment">//     char v;</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.push_back(v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(c);    <span class="comment">// pack the string</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Iterator range</dt><dd>Sometimes you only have a begin and an end iterators to do the packing/unpacking. A <code>size_t *</code> parameter might be provided to retrieve the number of elements actually packed/unpacked. If it doesn't matter, just ignore it. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">list&lt;int&gt; c;</div><div class="line">list&lt;int&gt;::iterator first = c.begin();  <span class="comment">// start iterator</span></div><div class="line">list&lt;int&gt;::iterator last = c.end();     <span class="comment">// end iterator</span></div><div class="line"><span class="keywordtype">size_t</span> sz;</div><div class="line"></div><div class="line">in &gt;&gt; Mapip::raw(first, last, &amp;sz);  <span class="comment">// unpack certain integers to range [first, last), and</span></div><div class="line">                                     <span class="comment">// store the number of elements unpaced in &#39;sz&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(list&lt;int&gt;::iterator it = first;it != last;++it)</span></div><div class="line"><span class="comment">//     in &gt;&gt; *it;</span></div></div><!-- fragment --> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">list&lt;int&gt; c;</div><div class="line">list&lt;int&gt;::const_iterator first = c.begin();  <span class="comment">// start iterator</span></div><div class="line">list&lt;int&gt;::const_iterator last = c.end();     <span class="comment">// end iterator</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::raw(first, last);  <span class="comment">// pack certain integers from range [first, last), not</span></div><div class="line">                                 <span class="comment">// interested in the number of elements packed</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// for(list&lt;int&gt;::const_iterator it = first;it != last;++it)</span></div><div class="line"><span class="comment">//     out &lt;&lt; *it;</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:ab85bcd346ad33876acd996432ca54e73"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab85bcd346ad33876acd996432ca54e73"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:ab85bcd346ad33876acd996432ca54e73"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (T(&amp;c)[N])</td></tr>
<tr class="separator:ab85bcd346ad33876acd996432ca54e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ae085e46b34b6585fa3cbc24e77b37"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae6ae085e46b34b6585fa3cbc24e77b37"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae6ae085e46b34b6585fa3cbc24e77b37"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (T *c, size_t sz)</td></tr>
<tr class="separator:ae6ae085e46b34b6585fa3cbc24e77b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d825102aad20360a0c38ab071986969"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d825102aad20360a0c38ab071986969"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d825102aad20360a0c38ab071986969"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (std::vector&lt; T &gt; &amp;c, size_t sz)</td></tr>
<tr class="separator:a6d825102aad20360a0c38ab071986969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5576194348c8f9a4d39c3ab31588796c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5576194348c8f9a4d39c3ab31588796c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5576194348c8f9a4d39c3ab31588796c"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (const std::vector&lt; T &gt; &amp;c, size_t *sz=NULL)</td></tr>
<tr class="separator:a5576194348c8f9a4d39c3ab31588796c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f584c43cd3f3cb80ea4cf740cbf15"><td class="memTemplParams" colspan="2"><a class="anchor" id="a154f584c43cd3f3cb80ea4cf740cbf15"></a>
template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a154f584c43cd3f3cb80ea4cf740cbf15"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; Char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (std::basic_string&lt; Char &gt; &amp;c, size_t len)</td></tr>
<tr class="separator:a154f584c43cd3f3cb80ea4cf740cbf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca62b8f5e33e710a85846d814763ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1bca62b8f5e33e710a85846d814763ce"></a>
template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a1bca62b8f5e33e710a85846d814763ce"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawPtr&lt; const Char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (const std::basic_string&lt; Char &gt; &amp;c, size_t *sz=NULL)</td></tr>
<tr class="separator:a1bca62b8f5e33e710a85846d814763ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423e0cbaf0a71fb7e67a0e7d6424fc87"><td class="memTemplParams" colspan="2"><a class="anchor" id="a423e0cbaf0a71fb7e67a0e7d6424fc87"></a>
template&lt;class ForwardIter &gt; </td></tr>
<tr class="memitem:a423e0cbaf0a71fb7e67a0e7d6424fc87"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawRange&lt; ForwardIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (ForwardIter first, ForwardIter last, size_t *sz=NULL)</td></tr>
<tr class="separator:a423e0cbaf0a71fb7e67a0e7d6424fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286a48755fb37057515deb0f1555799a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a286a48755fb37057515deb0f1555799a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a286a48755fb37057515deb0f1555799a"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawCont&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (T &amp;c, size_t sz)</td></tr>
<tr class="separator:a286a48755fb37057515deb0f1555799a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528bd13e2fe97161ff1e717a12d574f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a528bd13e2fe97161ff1e717a12d574f4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a528bd13e2fe97161ff1e717a12d574f4"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorRawCont&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>raw</b> (const T &amp;c, size_t *sz=NULL)</td></tr>
<tr class="separator:a528bd13e2fe97161ff1e717a12d574f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapip::array</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Pack/unpack a range of elements, <em>with</em> leading size field.</p>
<p><code>Mapip::array</code> is convenient for pack/unpack a number of elements, like an array, a string of characters, or a container. It is very similar to <code>Manip::raw</code>, except that a size field (the number elements) is packed/unpacked first before the elements. By default, the type of leading size field is <code>uint16_t</code>, unless you specify it explicitly. </p><dl class="section user"><dt>Array</dt><dd>Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[10];   <span class="comment">// an array to receive unpacked results</span></div><div class="line">uint8_t sz;  <span class="comment">// an integer to retrieve the number of elements actually unpacked</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c, &amp;sz);  <span class="comment">// firstly unpack an uint8_t to &#39;sz&#39; as the number of following</span></div><div class="line">                             <span class="comment">// elements, then unpack &#39;sz&#39; integers to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// in &gt;&gt; sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Note that if <code>sz</code> is larger than the size <code>c</code> can hold, the whole operation fails with status of <code>in</code> set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> c[5];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint16_t&gt;(c);   <span class="comment">// pack a uint16_t equals to 5, then pack 5 integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(5);</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; 5;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that you <em>must</em> specify the type of leading size. <br />
 If size of array cannot be deduced automatically, a parameter must be provided. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];   <span class="comment">// an array to receive unpacked results</span></div><div class="line">uint16_t real_sz;        <span class="comment">// an integer to retrieve the number of elements actually unpacked</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c, sz, &amp;real_sz);<span class="comment">// firstly unpack a uin16_t to &#39;real_sz&#39; as the number of</span></div><div class="line">                                    <span class="comment">// following elements, then unpack &#39;real_sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// in &gt;&gt; real_sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; real_sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> Note that if <code>real_sz</code> is larger than <code>sz</code>, the whole operation fails with status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> * c = <span class="keyword">new</span> <span class="keywordtype">int</span>[sz];    <span class="comment">// an array to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint16_t&gt;(c, sz);    <span class="comment">// pack a uint16_t equals to &#39;sz&#39; first, then pack</span></div><div class="line">                                         <span class="comment">// &#39;sz&#39; integers</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(sz);</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that you <em>must</em> specify the type of leading size. </dd></dl>
<dl class="section user"><dt>Containers</dt><dd>Most STL containers are well supported, e.g. <code>vector</code>, <code>list</code>, <code>deque</code>, <code>set/multiset</code>, <code>map/multimap</code>, etc. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// a container to receive unpacked results</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c);  <span class="comment">// firstly unpack a uint16_t as the number of following elements,</span></div><div class="line">                        <span class="comment">// then unpack that number of integers, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// uint16_t sz;</span></div><div class="line"><span class="comment">// in &gt;&gt; sz;</span></div><div class="line"><span class="comment">// for(int i = 0, v;i &lt; sz;++i){</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.insert(c.end(), v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> If the leading size is not <code>uint16_t</code>, you can specify it like this: <div class="fragment"><div class="line">in &gt;&gt; Mapip::array&lt;uint8_t&gt;(c);  <span class="comment">// firstly unpack a uint8_t as the number of following</span></div><div class="line">                                 <span class="comment">// elements, then unpack that number of integers, and</span></div><div class="line">                                 <span class="comment">// append them to &#39;c&#39;</span></div></div><!-- fragment --> If there is a limitation of elements, an additional parameter may be provided, and the leading size has the same type as the second parameter: <div class="fragment"><div class="line">uint32_t max_sz = 100;</div><div class="line">in &gt;&gt; Mapip::array(c, max_sz);   <span class="comment">// firstly unpack a uint32_t as the number of following</span></div><div class="line">                                 <span class="comment">// elements, then unpack that number of integers, and</span></div><div class="line">                                 <span class="comment">// append them to &#39;c&#39;</span></div></div><!-- fragment --> If the leading size unpacked is larger than <code>max_sz</code>, the operation fails and status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">vector&lt;int&gt; c;    <span class="comment">// an vector to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array(c);  <span class="comment">// firstly pack a uint16_t equals to &#39;c.size()&#39;, then pack all</span></div><div class="line">                         <span class="comment">// elements in &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(c.size());</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that you can specify the type of leading size like this: <div class="fragment"><div class="line">out &lt;&lt; Mapip::array&lt;uint8_t&gt;(c); <span class="comment">// firstly pack a uint8_t equals to &#39;c.size()&#39;, then pack</span></div><div class="line">                                 <span class="comment">//all elements in &#39;c&#39;</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>String</dt><dd>A C-style string is essentially an array of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> * c = <span class="keyword">new</span> <span class="keywordtype">char</span>[sz]; <span class="comment">// an array of chars to receive unpacked results</span></div><div class="line">uint16_t real_sz;        <span class="comment">// an integer to retrieve the number characters actually unpacked</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c, sz, &amp;real_sz);  <span class="comment">// firstly unpack a uint16_t to &#39;real_sz&#39; as the</span></div><div class="line">                                      <span class="comment">// number of following characters, then unpack</span></div><div class="line">                                      <span class="comment">// &#39;real_sz&#39; characters to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// in &gt;&gt; real_sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; real_sz;++i)</span></div><div class="line"><span class="comment">//     in &gt;&gt; c[i];</span></div></div><!-- fragment --> If <code>real_sz</code> is larger than <code>sz</code>, this operation fails and status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a C-style string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint8_t&gt;(c, strlen(c));    <span class="comment">// firstly pack a uint8_t equals to</span></div><div class="line">                                               <span class="comment">// &#39;strlen(c)&#39;, then pack the content of &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint8_t(strlen(c));</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; strlen(c);++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> Note that the type of leading size <em>must</em> be provided. <br />
 An <code>std::string</code> is a container of characters. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c;    <span class="comment">// an object to receive unpacked data</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::array(c);  <span class="comment">// firstly unpack a uint16_t as the number of following characters,</span></div><div class="line">                        <span class="comment">// then unpack that number of bytes of data, and append them to &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// uint16_t sz;</span></div><div class="line"><span class="comment">// in &gt;&gt; sz;</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; sz;++i){</span></div><div class="line"><span class="comment">//     char v;</span></div><div class="line"><span class="comment">//     in &gt;&gt; v;</span></div><div class="line"><span class="comment">//     c.push_back(v);</span></div><div class="line"><span class="comment">// }</span></div></div><!-- fragment --> You can specify the type of leading size like this: <div class="fragment"><div class="line">in &gt;&gt; Mapip::array&lt;uint8_t&gt;(c);  <span class="comment">// firstly unpack a uint8_t as the number of following</span></div><div class="line">                                 <span class="comment">// characters, then unpack that number of bytes of data,</span></div><div class="line">                                 <span class="comment">// and append them to &#39;c&#39;</span></div></div><!-- fragment --> If there is a limitation of bytes to unpack, an additional parameter may be provided, and the type of leading size is the same as the second parameter: <div class="fragment"><div class="line">uint8_t max_sz = 100;</div><div class="line">in &gt;&gt; Mapip::array(c, max_sz);   <span class="comment">// firstly unpack a uint8_t as the number of following</span></div><div class="line">                                 <span class="comment">// characters, then unpack that number of bytes of data,</span></div><div class="line">                                 <span class="comment">// and append them to &#39;c&#39;</span></div></div><!-- fragment --> If the leading size unpacked is larger than <code>max_sz</code>, the operation fails and status of <code>in</code> is set to non-zero. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="keywordtype">string</span> c = <span class="stringliteral">&quot;abcde&quot;</span>;    <span class="comment">// a string to pack</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array(c);  <span class="comment">// firstly pack a uint16_t equals to &#39;c.size()&#39;, then pack the</span></div><div class="line">                         <span class="comment">// content of &#39;c&#39;</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(c.size());</span></div><div class="line"><span class="comment">// for(int i = 0;i &lt; c.size();++i)</span></div><div class="line"><span class="comment">//     out &lt;&lt; c[i];</span></div></div><!-- fragment --> If the type of leading size isn't <code>uint16_t</code>, you can specify it like this: <div class="fragment"><div class="line">out &lt;&lt; Mapip::array&lt;uint8_t&gt;(c); <span class="comment">// firstly pack a uint8_t equals to &#39;c.size()&#39;, then pack</span></div><div class="line">                                 <span class="comment">// the content of &#39;c&#39;</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Iterator range (pack only)</dt><dd>Sometimes you only have a begin and an end iterators to do the packing. <br />
 Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">list&lt;int&gt; c;</div><div class="line">list&lt;int&gt;::const_iterator first = c.begin();  <span class="comment">// start iterator</span></div><div class="line">list&lt;int&gt;::const_iterator last = c.end();     <span class="comment">// end iterator</span></div><div class="line"></div><div class="line">out &lt;&lt; Mapip::array&lt;uint16_t&gt;(first, last);<span class="comment">// firstly pack a uint16_t equals to the number of</span></div><div class="line">                                           <span class="comment">// elements in range [first, last), then pack all</span></div><div class="line">                                           <span class="comment">// integers the range</span></div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// out &lt;&lt; uint16_t(distance(first, last));</span></div><div class="line"><span class="comment">// for(list&lt;int&gt;::const_iterator it = first;it != last;++it)</span></div><div class="line"><span class="comment">//     out &lt;&lt; *it;</span></div></div><!-- fragment --> An additional integer parameter could be provided to retrieve the number of elements packed, and it will have the same type of the leading size: <div class="fragment"><div class="line">uint8_t sz;</div><div class="line">out &lt;&lt; Mapip::array(first, last, &amp;sz);   <span class="comment">// firstly pack a uint8_t equals to the number of</span></div><div class="line">                                         <span class="comment">// elements in range [first, last), then pack all</span></div><div class="line">                                         <span class="comment">// integers in the range</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a4e99d69171c39ace6c3e79620a595158"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e99d69171c39ace6c3e79620a595158"></a>
template&lt;typename LenT , class T , size_t N&gt; </td></tr>
<tr class="memitem:a4e99d69171c39ace6c3e79620a595158"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (T(&amp;c)[N], LenT *real_sz)</td></tr>
<tr class="separator:a4e99d69171c39ace6c3e79620a595158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970c820185fe8a0dd64c9b105f8015eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a970c820185fe8a0dd64c9b105f8015eb"></a>
template&lt;typename LenT , class T , size_t N&gt; </td></tr>
<tr class="memitem:a970c820185fe8a0dd64c9b105f8015eb"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (const T(&amp;c)[N])</td></tr>
<tr class="separator:a970c820185fe8a0dd64c9b105f8015eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e87f2b94e1520851052424752b93257"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e87f2b94e1520851052424752b93257"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a4e87f2b94e1520851052424752b93257"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (T *c, size_t sz, LenT *real_sz)</td></tr>
<tr class="separator:a4e87f2b94e1520851052424752b93257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917c42274cf0dcc84bb1bed1cdbb94f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a917c42274cf0dcc84bb1bed1cdbb94f6"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a917c42274cf0dcc84bb1bed1cdbb94f6"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayPtr&lt; LenT, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (const T *c, size_t sz)</td></tr>
<tr class="separator:a917c42274cf0dcc84bb1bed1cdbb94f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6c5e8ca4296b32fdf7121669244464"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d6c5e8ca4296b32fdf7121669244464"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a6d6c5e8ca4296b32fdf7121669244464"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; LenT, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (T &amp;c, LenT max_size=0)</td></tr>
<tr class="separator:a6d6c5e8ca4296b32fdf7121669244464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0935e1208826a1912518cbeea3e13a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f0935e1208826a1912518cbeea3e13a"></a>
template&lt;typename LenT , class T &gt; </td></tr>
<tr class="memitem:a2f0935e1208826a1912518cbeea3e13a"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; LenT, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (const T &amp;c)</td></tr>
<tr class="separator:a2f0935e1208826a1912518cbeea3e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547649a191ffd803cbcb35a7939c44a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a547649a191ffd803cbcb35a7939c44a5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a547649a191ffd803cbcb35a7939c44a5"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; uint16_t, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (T &amp;c, uint16_t max_size=0)</td></tr>
<tr class="separator:a547649a191ffd803cbcb35a7939c44a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7195b9b13638bdcfbe3edb910f17066e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7195b9b13638bdcfbe3edb910f17066e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7195b9b13638bdcfbe3edb910f17066e"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayCont&lt; uint16_t, const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (const T &amp;c)</td></tr>
<tr class="separator:a7195b9b13638bdcfbe3edb910f17066e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989fd001d06e4cbb1c87679801393ef6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a989fd001d06e4cbb1c87679801393ef6"></a>
template&lt;typename LenT , class ForwardIter &gt; </td></tr>
<tr class="memitem:a989fd001d06e4cbb1c87679801393ef6"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorArrayRange&lt; LenT, ForwardIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> (ForwardIter first, ForwardIter last, LenT *sz=NULL)</td></tr>
<tr class="separator:a989fd001d06e4cbb1c87679801393ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Byte order</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>APIs for changing <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> / <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a> object's byte order, both permanently and temporarily.</p>
<dl class="section user"><dt>Change byte order permanently.</dt><dd>Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Net Byte Order (Big Endian).</span></div><div class="line">in &gt;&gt; Mapip::net_order;</div><div class="line">out &lt;&lt; Manip::net_order;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Host Byte Order.</span></div><div class="line">in &gt;&gt; Mapip::host_order;</div><div class="line">out &lt;&lt; Manip::host_order;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Little Endian.</span></div><div class="line">in &gt;&gt; Mapip::little_endian;</div><div class="line">out &lt;&lt; Manip::little_endian;</div><div class="line"></div><div class="line"><span class="comment">// Set the underlying data buffer as Big Endian (Net Byte Order).</span></div><div class="line">in &gt;&gt; Mapip::big_endian;</div><div class="line">out &lt;&lt; Manip::big_endian;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Change byte order temporarily.</dt><dd>Set byte order and pack/unpack data, then restore old byte order. <br />
 Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"><span class="keywordtype">int</span> val = 10;</div><div class="line"></div><div class="line">in &gt;&gt; Mapip::net_order_value(val);   <span class="comment">// unpack an integer using Net Byte Order, despite</span></div><div class="line">                                     <span class="comment">// the actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::net_order_value(val);  <span class="comment">// pack an integer using Net Byte Order, dspite the</span></div><div class="line">                                     <span class="comment">// actual byte order of &#39;out&#39;</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::host_order_value(val);  <span class="comment">// unpack an integer using Host Byte Order, despite</span></div><div class="line">                                     <span class="comment">// the actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::host_order_value(val); <span class="comment">// pack an integer using Host Byte Order, dspite the</span></div><div class="line">                                     <span class="comment">// actual byte order of &#39;out&#39;</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::little_endian_value(val);   <span class="comment">// unpack an integer using Little Endian, despite</span></div><div class="line">                                         <span class="comment">// the actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::little_endian_value(val);  <span class="comment">// pack an integer using Little Endian, dspite the</span></div><div class="line">                                         <span class="comment">// actual byte order of &#39;out&#39;</span></div><div class="line"></div><div class="line">in &gt;&gt; Mapip::big_endian_value(val);  <span class="comment">// unpack an integer using Big Endian, despite the</span></div><div class="line">                                     <span class="comment">// actual byte order of &#39;in&#39;</span></div><div class="line">out &lt;&lt; Mapip::big_endian_value(val); <span class="comment">// pack an integer using Big Endian, dspite the actual</span></div><div class="line">                                     <span class="comment">// byte order of &#39;out&#39;</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a3c1de7bc8ce8731d798a601a9d5ee945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c1de7bc8ce8731d798a601a9d5ee945"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>net_order</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:a3c1de7bc8ce8731d798a601a9d5ee945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1699e4a8bd8f85b3da32cfce3f604f52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1699e4a8bd8f85b3da32cfce3f604f52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>host_order</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:a1699e4a8bd8f85b3da32cfce3f604f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c392998b461db2e22412654ed8c753e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c392998b461db2e22412654ed8c753e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>little_endian</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:a2c392998b461db2e22412654ed8c753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f613f2d431f89a9d7679c570fbfcbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f613f2d431f89a9d7679c570fbfcbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>big_endian</b> (NS_IMPL::CDataStreamBase &amp;ds)</td></tr>
<tr class="separator:ac0f613f2d431f89a9d7679c570fbfcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4663bdaff02553c02817377d3771b2c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4663bdaff02553c02817377d3771b2c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4663bdaff02553c02817377d3771b2c5"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>net_order_value</b> (T &amp;val)</td></tr>
<tr class="separator:a4663bdaff02553c02817377d3771b2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff161eb3ee449c0fbfdec9fcbe48f6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1ff161eb3ee449c0fbfdec9fcbe48f6a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1ff161eb3ee449c0fbfdec9fcbe48f6a"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>net_order_value</b> (const T &amp;val)</td></tr>
<tr class="separator:a1ff161eb3ee449c0fbfdec9fcbe48f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44568225662d1c1229449cdb76151b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab44568225662d1c1229449cdb76151b5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab44568225662d1c1229449cdb76151b5"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>host_order_value</b> (T &amp;val)</td></tr>
<tr class="separator:ab44568225662d1c1229449cdb76151b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03877733c8e1da3bc031b2879451c6a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03877733c8e1da3bc031b2879451c6a4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a03877733c8e1da3bc031b2879451c6a4"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>host_order_value</b> (const T &amp;val)</td></tr>
<tr class="separator:a03877733c8e1da3bc031b2879451c6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09592f8c9925084a3830ba24fb2647a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a09592f8c9925084a3830ba24fb2647a1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a09592f8c9925084a3830ba24fb2647a1"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>little_endian_value</b> (T &amp;val)</td></tr>
<tr class="separator:a09592f8c9925084a3830ba24fb2647a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34fc3a693fa6bda1f174799c99970a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac34fc3a693fa6bda1f174799c99970a6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac34fc3a693fa6bda1f174799c99970a6"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>little_endian_value</b> (const T &amp;val)</td></tr>
<tr class="separator:ac34fc3a693fa6bda1f174799c99970a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b7ae5eaf80ca2e9399929d8f5f3fde"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16b7ae5eaf80ca2e9399929d8f5f3fde"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16b7ae5eaf80ca2e9399929d8f5f3fde"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>big_endian_value</b> (T &amp;val)</td></tr>
<tr class="separator:a16b7ae5eaf80ca2e9399929d8f5f3fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ded354ba3283bb2f6017352eaa1f33f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ded354ba3283bb2f6017352eaa1f33f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ded354ba3283bb2f6017352eaa1f33f"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorValueByteOrder&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>big_endian_value</b> (const T &amp;val)</td></tr>
<tr class="separator:a2ded354ba3283bb2f6017352eaa1f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Current position</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>APIs for changing current position, both permanently and temporarily.</p>
<dl class="section user"><dt>Change current postion permanently</dt><dd>Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line"><span class="comment">// Set current position absolutely</span></div><div class="line">in &gt;&gt; Mapip::seek(10);   <span class="comment">// Same as in.seek(10)</span></div><div class="line">out &lt;&lt; Mapip::seek(10);  <span class="comment">// Same as out.seek(10)</span></div><div class="line"></div><div class="line"><span class="comment">// Move current position relatively</span></div><div class="line">in &gt;&gt; Mapip::skip(10);   <span class="comment">// Same as in.skip(10)</span></div><div class="line">out &lt;&lt; Mapip::skip(10);  <span class="comment">// Same as out.skip(10)</span></div><div class="line">uint32_t off = -10;</div><div class="line">in &gt;&gt; Mapip::skip(&amp;off);   <span class="comment">// Same as in.skip(off)</span></div><div class="line">out &lt;&lt; Mapip::skip(&amp;off);  <span class="comment">// Same as out.skip(off)</span></div><div class="line"></div><div class="line"><span class="comment">// Fill while moving</span></div><div class="line"><span class="keywordtype">int</span> fill = <span class="charliteral">&#39;a&#39;</span>;</div><div class="line">in &gt;&gt; Mapip::skip(10, fill);   <span class="comment">// Same as in.skip(10, fill)</span></div><div class="line">out &lt;&lt; Mapip::skip(10, fill);  <span class="comment">// Same as out.skip(10, fill)</span></div><div class="line">uint32_t off = -10;</div><div class="line">in &gt;&gt; Mapip::skip(&amp;off, fill);   <span class="comment">// Same as in.skip(off, fill)</span></div><div class="line">out &lt;&lt; Mapip::skip(&amp;off, fill);  <span class="comment">// Same as out.skip(off, fill)</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Change current postion temporarily</dt><dd>Move current position and pack/unpack data, then restore old current position. <br />
 Sample code: <div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"><span class="keywordtype">int</span> val = 100;</div><div class="line"></div><div class="line"><span class="comment">// Unpack data from an absolute position</span></div><div class="line">in &gt;&gt; Mapip::offset_value(10, val);</div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// size_t old = in.cur();</span></div><div class="line"><span class="comment">// in.seek(10);</span></div><div class="line"><span class="comment">// in &gt;&gt; val;</span></div><div class="line"><span class="comment">// in.seek(old);</span></div><div class="line"></div><div class="line"><span class="comment">// Pack data to an absolute position</span></div><div class="line">out &lt;&lt; Mapip::offset_value(10, val);</div><div class="line"><span class="comment">// This is equivalent to:</span></div><div class="line"><span class="comment">// size_t old = out.cur();</span></div><div class="line"><span class="comment">// out.seek(10);</span></div><div class="line"><span class="comment">// out &lt;&lt; val;</span></div><div class="line"><span class="comment">// out.seek(old);</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Insert data (pack only)</dt><dd>Sometimes you need to <em>insert</em> a value to a particular position in already packed data, which means all existing data after that position need to move forward, to make room for the value. This operation could be complex without <code>Manip::insert</code>. <br />
 Sample code: <div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"><span class="keywordtype">int</span> val = 100;</div><div class="line"></div><div class="line">out &lt;&lt; Mapip::insert(10, val);   <span class="comment">// pack &#39;val&#39; at absolute position 10. Any existing data</span></div><div class="line">                                 <span class="comment">// after this position will move forward by &#39;sizeof val&#39;</span></div><div class="line">                                 <span class="comment">// bytes to make room for &#39;val&#39;</span></div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a14ea14fc2e71a30bede372a98153c027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14ea14fc2e71a30bede372a98153c027"></a>
NS_IMPL::CManipulatorSeek&#160;</td><td class="memItemRight" valign="bottom"><b>seek</b> (size_t pos)</td></tr>
<tr class="separator:a14ea14fc2e71a30bede372a98153c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063b64e4fb346e13ed9d1af9ea30f8c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a063b64e4fb346e13ed9d1af9ea30f8c5"></a>
NS_IMPL::CManipulatorSkip&#160;</td><td class="memItemRight" valign="bottom"><b>skip</b> (ssize_t off)</td></tr>
<tr class="separator:a063b64e4fb346e13ed9d1af9ea30f8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671171c2631bb29028ac41d8f4cb3497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a671171c2631bb29028ac41d8f4cb3497"></a>
NS_IMPL::CManipulatorSkipFill&#160;</td><td class="memItemRight" valign="bottom"><b>skip</b> (ssize_t off, int fill)</td></tr>
<tr class="separator:a671171c2631bb29028ac41d8f4cb3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e9d14ee9a406661d613dac9aedd1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb7e9d14ee9a406661d613dac9aedd1e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb7e9d14ee9a406661d613dac9aedd1e"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorSkipPtr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skip</b> (T *off)</td></tr>
<tr class="separator:aeb7e9d14ee9a406661d613dac9aedd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5ad05beafbb83df2c240c7dccbdae2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d5ad05beafbb83df2c240c7dccbdae2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d5ad05beafbb83df2c240c7dccbdae2"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorSkipPtrFill&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skip</b> (T *off, int fill)</td></tr>
<tr class="separator:a4d5ad05beafbb83df2c240c7dccbdae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e85d76fd1c515736a254a69b1dfef68"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e85d76fd1c515736a254a69b1dfef68"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7e85d76fd1c515736a254a69b1dfef68"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorOffsetValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>offset_value</b> (size_t pos, T &amp;val)</td></tr>
<tr class="separator:a7e85d76fd1c515736a254a69b1dfef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12a05506ad9badef66ed03beede5857"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa12a05506ad9badef66ed03beede5857"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa12a05506ad9badef66ed03beede5857"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorOffsetValue&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>offset_value</b> (size_t pos, const T &amp;val)</td></tr>
<tr class="separator:aa12a05506ad9badef66ed03beede5857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9137e5a44991cc549b29c73389d1526"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9137e5a44991cc549b29c73389d1526"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac9137e5a44991cc549b29c73389d1526"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorInsert&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (size_t pos, const T &amp;val)</td></tr>
<tr class="separator:ac9137e5a44991cc549b29c73389d1526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manip::end</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>End packing/unpacking operations.</p>
<p>When all packing/unpacking operations finish, it's a good practice to announce an <code>end</code> explicitly. <br />
 For unpacking operations (<a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>), left data size will be checked. If it's not zero, status of <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a> object will be set to non-zero. Because usually some left data means you have missed something, or there is a misunderstanding about the protocol. <br />
 For packing operations (<a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>), it's always necessary to <code>end</code>. Because the underlying data buffer (whether it's internal or external) may have reserved some room for performance, so an adjustment is critical to correct its size. Besides, it will call corresponding <a class="el" href="classCOutByteStreamBasic.html#a944b54097f754a3dd27d97e2bc0c52e2">COutByteStreamBasic::finish</a> to export data. </p><dl class="section note"><dt>Note</dt><dd>Ending operation will clear all stubs, without any alignments or checks. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCOutByteStreamBasic.html#a944b54097f754a3dd27d97e2bc0c52e2" title="Export data for COutByteStreamStrRef, COutByteStreamVecRef. ">COutByteStreamBasic::finish</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a73ecc2775c7844cb4ca9566cd115043d"><td class="memItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; void, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">end</a> ()</td></tr>
<tr class="memdesc:a73ecc2775c7844cb4ca9566cd115043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="classCInByteStream.html">CInByteStream</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>.  <a href="#a73ecc2775c7844cb4ca9566cd115043d">More...</a><br /></td></tr>
<tr class="separator:a73ecc2775c7844cb4ca9566cd115043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791fd267a1c67d68c52fab09cf53fb4b"><td class="memTemplParams" colspan="2">template&lt;typename SizeT &gt; </td></tr>
<tr class="memitem:a791fd267a1c67d68c52fab09cf53fb4b"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; SizeT *, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a791fd267a1c67d68c52fab09cf53fb4b">end</a> (SizeT *sz)</td></tr>
<tr class="memdesc:a791fd267a1c67d68c52fab09cf53fb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>.  <a href="#a791fd267a1c67d68c52fab09cf53fb4b">More...</a><br /></td></tr>
<tr class="separator:a791fd267a1c67d68c52fab09cf53fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8e99fa7b7888b311ff70615972f651"><td class="memTemplParams" colspan="2">template&lt;class BufT &gt; </td></tr>
<tr class="memitem:a6c8e99fa7b7888b311ff70615972f651"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; BufT, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a6c8e99fa7b7888b311ff70615972f651">end</a> (BufT &amp;buf)</td></tr>
<tr class="memdesc:a6c8e99fa7b7888b311ff70615972f651"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>.  <a href="#a6c8e99fa7b7888b311ff70615972f651">More...</a><br /></td></tr>
<tr class="separator:a6c8e99fa7b7888b311ff70615972f651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539de852da4658c596026d1aa9d5669c"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; </td></tr>
<tr class="memitem:a539de852da4658c596026d1aa9d5669c"><td class="memTemplItemLeft" align="right" valign="top">NS_IMPL::CManipulatorEnd&lt; CharT *, size_t * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceManip.html#a539de852da4658c596026d1aa9d5669c">end</a> (CharT *buf, size_t *sz)</td></tr>
<tr class="memdesc:a539de852da4658c596026d1aa9d5669c"><td class="mdescLeft">&#160;</td><td class="mdescRight">End operations for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>, <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a>.  <a href="#a539de852da4658c596026d1aa9d5669c">More...</a><br /></td></tr>
<tr class="separator:a539de852da4658c596026d1aa9d5669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manipulators for stream interface APIs. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a73ecc2775c7844cb4ca9566cd115043d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorEnd&lt;void, void&gt; Manip::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End operations for <a class="el" href="classCInByteStream.html">CInByteStream</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>. </p>
<p>Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, 8);</div><div class="line">uint32_t val;</div><div class="line"></div><div class="line">in &gt;&gt; val;               <span class="comment">// unpack a 4-byte integer</span></div><div class="line"><span class="comment">// in &gt;&gt; Manip::end;     // FAIL! There are 4 bytes left</span></div><div class="line"></div><div class="line">in &gt;&gt; val;               <span class="comment">// unpack another 4-byte integer</span></div><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a>;        <span class="comment">// Fine, no left data</span></div></div><!-- fragment --><p> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> buf;</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStreamStrRef</a> out(buf);   <span class="comment">// &#39;buf&#39; is the underlying buffer for &#39;out&#39;</span></div><div class="line"></div><div class="line">out &lt;&lt; uint32_t(100);        <span class="comment">// pack a 4-byte integer,</span></div><div class="line"><span class="comment">// assert(buf.size() == 4);  // ERROR! buf.size() &gt;= 4</span></div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a>;           <span class="comment">// adjust buf.size()</span></div><div class="line">assert(buf.size() == 4);     <span class="comment">// Correct</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a791fd267a1c67d68c52fab09cf53fb4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorEnd&lt;SizeT *, void&gt; Manip::end </td>
          <td>(</td>
          <td class="paramtype">SizeT *&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End operations for <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>. </p>
<p>This manipulator will also store the byte size of underlying data buffer in <code>sz</code>. <br />
 Sample code: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> * buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[10];</div><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStreamBuf</a> out(buf, 10);  <span class="comment">// &#39;buf&#39; is the underlying buffer for &#39;out&#39;</span></div><div class="line"></div><div class="line">out &lt;&lt; uint32_t(100);        <span class="comment">// pack a 4-byte integer,</span></div><div class="line"></div><div class="line"><span class="keywordtype">size_t</span> sz;</div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a>(&amp;sz);      <span class="comment">// set correct size to &#39;sz&#39;</span></div><div class="line">assert(sz == 4);             <span class="comment">// Correct</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeT</td><td>Type of an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sz</td><td>Pointer to an integer to receive the size of actual data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c8e99fa7b7888b311ff70615972f651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BufT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorEnd&lt;BufT, void&gt; Manip::end </td>
          <td>(</td>
          <td class="paramtype">BufT &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End operations for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>. </p>
<p>This manipulator will also export data to <code>buf</code>. If it's not empty, new data will append to it. <br />
 Sample code: </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">out &lt;&lt; uint32_t(100);    <span class="comment">// pack a 4-byte integer</span></div><div class="line"></div><div class="line"><span class="keywordtype">string</span> buf;</div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a>(buf);  <span class="comment">// export data to &#39;buf&#39;</span></div><div class="line">assert(buf.size() == 4); <span class="comment">// Correct</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Data copy is avoided whenever possible, e.g. <code>buf</code> is empty and the underlying buffer is internal (<a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a> and <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>). </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufT</td><td>Must be the same as the underlying buffer type, e.g. <code>std::string</code> for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, or <code>std::vector&lt;char&gt;</code> for <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer to receive data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a539de852da4658c596026d1aa9d5669c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorEnd&lt;CharT *, size_t *&gt; Manip::end </td>
          <td>(</td>
          <td class="paramtype">CharT *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End operations for <a class="el" href="data__stream_8hh.html#a47c079c52e5385473976281ce00251ab">COutByteStream</a> / <a class="el" href="data__stream_8hh.html#a0ef01e09d25bd19584df091684fd736c">COutByteStreamStr</a>, <a class="el" href="data__stream_8hh.html#a8437a5fc88be591f9b1525fff60ccc82">COutByteStreamStrRef</a>, <a class="el" href="data__stream_8hh.html#ad8bd78a8893b4db9e628d4c8f1996057">COutByteStreamVec</a>, <a class="el" href="data__stream_8hh.html#af39d48292420eb915840ecb1b005fece">COutByteStreamVecRef</a>, <a class="el" href="data__stream_8hh.html#afb6d169189f59f48cb8b8c19cea19b26">COutByteStreamBuf</a>. </p>
<p>Sample code; </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">out &lt;&lt; uint32_t(100);    <span class="comment">// pack a 4-byte integer</span></div><div class="line"></div><div class="line"><span class="keywordtype">char</span> * buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[10];</div><div class="line"><span class="keywordtype">size_t</span> sz = 10;</div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a73ecc2775c7844cb4ca9566cd115043d">Manip::end</a>(buf, &amp;sz); <span class="comment">// export data to &#39;buf&#39;</span></div><div class="line">assert(sz == 4);             <span class="comment">// Correct</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Must be the same as the underlying character type, e.g. <code>char</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to a byte array to receive the data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sz</td><td>Pass in as the length of <code>dst</code>; pass out as the real size of exported data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bd14c601e489bbe9a5e9781b4606c0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorProtobuf&lt;T&gt; Manip::protobuf </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack/unpack <a href="https://github.com/google/protobuf">Protocol Buffers</a> messages. </p>
<p>This manipulator makes protobuf messages easily cooperative with other data formats. Packing/unpacking a protobuf message is as simple as for an integer. Boundary checks are automatically done, data pointers are efficiently handled. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"></div><div class="line">AnyMessage msg;  <span class="comment">// any protobuf message object</span></div><div class="line"></div><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e">Manip::protobuf</a>(msg);  <span class="comment">// unpack &#39;msg&#39; from all left data of &#39;in&#39;</span></div></div><!-- fragment --><p> By default, <a class="el" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e" title="Pack/unpack Protocol Buffers messages. ">Manip::protobuf</a> will use all left data of <code>in</code> to initialize protobuf message object, which means the message should be the last value of <code>in</code>. <br />
 But if that's not the case, you must provide a size parameter to limit the reading: </p><div class="fragment"><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e">Manip::protobuf</a>(msg, 50);  <span class="comment">// unpack &#39;msg&#39; from 50 bytes of data of &#39;in&#39;</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In both cases <a class="el" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e" title="Pack/unpack Protocol Buffers messages. ">Manip::protobuf</a> will try to use all data available to initialize the message. If data size is incorrect, no matter smaller or larger than actually needed, this operation will fail and status of <code>in</code> will be set to non-zero.</dd></dl>
<p>Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">AnyMessage msg;  <span class="comment">// any protobuf message object</span></div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a8bd14c601e489bbe9a5e9781b4606c0e">Manip::protobuf</a>(msg); <span class="comment">// pack &#39;msg&#39;</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any subclass of <code>google::protobuf::MessageLite</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>A message object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of bytes read when unpacking <code>msg</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9007b4269e679af40fa9f5da3ad07ca4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorStubPush Manip::stub </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up a stub. </p>
<p>Any packing/unpacking operation cannot go beyond the stub, or it fails with status set to non-zero. <br />
 Stubs can stack, the top most one is currently in effect. After popping up it, the next top one takes effect immediately, until there is no stubs. <br />
 A common use of stubs is to create a robust hierarchical data structure in which errors in one part never affect other parts. Besides, additional boundary checks make defects harder to hide. <br />
 When creating a stub, you need provide offset of the stub, <code>sz</code>, relative to <em>current pointer</em>, i.e. the position of the stub is <code>cur() + sz</code>. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line">uint32_t val;</div><div class="line"></div><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">Manip::stub</a>(4);    <span class="comment">// Set up a stub at (in.cur() + 4)</span></div><div class="line">in &gt;&gt; val;               <span class="comment">// Fine, unpack a 4-byte integer</span></div><div class="line">in &gt;&gt; val;               <span class="comment">// FAIL! Can NOT go beyond the stub</span></div></div><!-- fragment --><p> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">Mapip::stub</a>(4);   <span class="comment">// Set up a stub at (out.cur() + 4)</span></div><div class="line">out &lt;&lt; uint32_t(100);    <span class="comment">// Fine, pack a 4-byte integer</span></div><div class="line">out &lt;&lt; <span class="charliteral">&#39;a&#39;</span>;              <span class="comment">// FAIL! Can NOT go beyong the stub</span></div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Offset of the stub, relative to <em>current pointer</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d3e0d1f84519db6f53f6e77ed5eb22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorStubPop Manip::stub_pop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Demolish the top most stub. </p>
<p>This manipulator demolishes current stub, check and align <em>current pointer</em> if needed. The next top stub will take effect, until there is no stubs any more. <br />
 Sample code for <a class="el" href="classCInByteStream.html" title="Data unpacking interfaces. ">CInByteStream</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line">uint32_t val;</div><div class="line"></div><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">Manip::stub</a>(4);    <span class="comment">// Set up a stub at (in.cur() + 4)</span></div><div class="line">in &gt;&gt; val;               <span class="comment">// Fine, unpack a 4-byte integer</span></div><div class="line"></div><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#a4d3e0d1f84519db6f53f6e77ed5eb22b">Mapip::stub_pop</a>()  <span class="comment">// Remove the stub</span></div><div class="line">in &gt;&gt; val;               <span class="comment">// Fine, unpack another 4-byte integer</span></div></div><!-- fragment --><p> Sample code for <a class="el" href="classCOutByteStreamBasic.html" title="Data packing interfaces. ">COutByteStreamBasic</a>: </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a9007b4269e679af40fa9f5da3ad07ca4">Mapip::stub</a>(4);   <span class="comment">// Set up a stub at (out.cur() + 4)</span></div><div class="line">out &lt;&lt; uint32_t(100);    <span class="comment">// Fine, pack a 4-byte integer</span></div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#a4d3e0d1f84519db6f53f6e77ed5eb22b">Manip::stub_pop</a>();<span class="comment">// remove the stub</span></div><div class="line">out &lt;&lt; <span class="charliteral">&#39;a&#39;</span>;              <span class="comment">// Fine, pack a char</span></div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td><ul>
<li><code>true:</code> Align <em>current pointer</em> to the position of removed stub. This is useful when you want to ignore any data in a sub-structure. </li>
<li><code>false:</code> Do not change <em>current pointer</em>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">check</td><td><ul>
<li><code>true:</code> Assert if <em>current pointer</em> equals to the position of removed stub. If failed, status will be set to non-zero. This is useful when you cannot tolerate any errors in the sub-structure. </li>
<li><code>false:</code> Do not check. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab181b437b00e3fabbfa66b62a778561f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorVarint&lt;const T&gt; Manip::varint </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack integer using <a href="http://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a> encoding. </p>
<p>Varint encoding is compact, byte order independent, and efficient. This manipulator makes it super easy to take advantage of it, and supports all primitive integer types, from <code>char</code> to <code>wchar_t</code> to <code>long long</code>. <br />
 Sample Code: </p><div class="fragment"><div class="line"><a class="code" href="classCOutByteStreamBasic.html">COutByteStream</a> out;</div><div class="line"></div><div class="line">out &lt;&lt; <a class="code" href="namespaceManip.html#ab181b437b00e3fabbfa66b62a778561f">Manip::varint</a>(1000);  <span class="comment">// pack number &#39;1000&#39; using Base 128 Varints encoding</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>An integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac625510fbd47e955faa40fbcff1a8496"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NS_IMPL::CManipulatorVarint&lt;T&gt; Manip::varint </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack integer using <a href="http://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varints</a> encoding. </p>
<p>Sample Code: </p><div class="fragment"><div class="line"><a class="code" href="classCInByteStream.html">CInByteStream</a> in(buf, sz);</div><div class="line"><span class="keywordtype">int</span> val;</div><div class="line"></div><div class="line">in &gt;&gt; <a class="code" href="namespaceManip.html#ab181b437b00e3fabbfa66b62a778561f">Manip::varint</a>(val);  <span class="comment">// unpack an integer to &#39;val&#39; using Base 128 Varints encoding</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>An integer to receive the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
